<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public\lib\angular-bootstrap\ui-bootstrap.js - MAGLE Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="..\..\modules\core\client\img\brand\logo.png" title="MAGLE Framework"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/A.html">&lt;A&gt;</a></li>
                                    <li><a href="../elements/ANY.html">&lt;ANY&gt;</a></li>
                                    <li><a href="../elements/DETAILS.html">&lt;DETAILS&gt;</a></li>
                                    <li><a href="../elements/form.html">&lt;form&gt;</a></li>
                                    <li><a href="../elements/html.html">&lt;html&gt;</a></li>
                                    <li><a href="../elements/IMG.html">&lt;IMG&gt;</a></li>
                                    <li><a href="../elements/INPUT.html">&lt;INPUT&gt;</a></li>
                                    <li><a href="../elements/input.html">&lt;input&gt;</a></li>
                                    <li><a href="../elements/OPTION.html">&lt;OPTION&gt;</a></li>
                                    <li><a href="../elements/window,.html">&lt;window,&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMessages.html">ngMessages</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: public\lib\angular-bootstrap\ui-bootstrap.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 0.13.4 - 2015-09-03
 * License: MIT
 */
angular.module(&quot;ui.bootstrap&quot;, [&quot;ui.bootstrap.collapse&quot;,&quot;ui.bootstrap.accordion&quot;,&quot;ui.bootstrap.alert&quot;,&quot;ui.bootstrap.bindHtml&quot;,&quot;ui.bootstrap.buttons&quot;,&quot;ui.bootstrap.carousel&quot;,&quot;ui.bootstrap.dateparser&quot;,&quot;ui.bootstrap.position&quot;,&quot;ui.bootstrap.datepicker&quot;,&quot;ui.bootstrap.dropdown&quot;,&quot;ui.bootstrap.modal&quot;,&quot;ui.bootstrap.pagination&quot;,&quot;ui.bootstrap.tooltip&quot;,&quot;ui.bootstrap.popover&quot;,&quot;ui.bootstrap.progressbar&quot;,&quot;ui.bootstrap.rating&quot;,&quot;ui.bootstrap.tabs&quot;,&quot;ui.bootstrap.timepicker&quot;,&quot;ui.bootstrap.transition&quot;,&quot;ui.bootstrap.typeahead&quot;]);
angular.module(&#x27;ui.bootstrap.collapse&#x27;, [])

  .directive(&#x27;collapse&#x27;, [&#x27;$animate&#x27;, function($animate) {
    return {
      link: function(scope, element, attrs) {
        function expand() {
          element.removeClass(&#x27;collapse&#x27;)
            .addClass(&#x27;collapsing&#x27;)
            .attr(&#x27;aria-expanded&#x27;, true)
            .attr(&#x27;aria-hidden&#x27;, false);

          $animate.addClass(element, &#x27;in&#x27;, {
            to: { height: element[0].scrollHeight + &#x27;px&#x27; }
          }).then(expandDone);
        }

        function expandDone() {
          element.removeClass(&#x27;collapsing&#x27;);
          element.css({height: &#x27;auto&#x27;});
        }

        function collapse() {
          if (!element.hasClass(&#x27;collapse&#x27;) &amp;&amp; !element.hasClass(&#x27;in&#x27;)) {
            return collapseDone();
          }

          element
            // IMPORTANT: The height must be set before adding &quot;collapsing&quot; class.
            // Otherwise, the browser attempts to animate from height 0 (in
            // collapsing class) to the given height here.
            .css({height: element[0].scrollHeight + &#x27;px&#x27;})
            // initially all panel collapse have the collapse class, this removal
            // prevents the animation from jumping to collapsed state
            .removeClass(&#x27;collapse&#x27;)
            .addClass(&#x27;collapsing&#x27;)
            .attr(&#x27;aria-expanded&#x27;, false)
            .attr(&#x27;aria-hidden&#x27;, true);

          $animate.removeClass(element, &#x27;in&#x27;, {
            to: {height: &#x27;0&#x27;}
          }).then(collapseDone);
        }

        function collapseDone() {
          element.css({height: &#x27;0&#x27;}); // Required so that collapse works when animation is disabled
          element.removeClass(&#x27;collapsing&#x27;);
          element.addClass(&#x27;collapse&#x27;);
        }

        scope.$watch(attrs.collapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module(&#x27;ui.bootstrap.accordion&#x27;, [&#x27;ui.bootstrap.collapse&#x27;])

.constant(&#x27;accordionConfig&#x27;, {
  closeOthers: true
})

.controller(&#x27;AccordionController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;accordionConfig&#x27;, function($scope, $attrs, accordionConfig) {
  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ?
      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if (closeOthers) {
      angular.forEach(this.groups, function(group) {
        if (group !== openGroup) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on(&#x27;$destroy&#x27;, function(event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if (index !== -1) {
      this.groups.splice(index, 1);
    }
  };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive(&#x27;accordion&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    controller: &#x27;AccordionController&#x27;,
    controllerAs: &#x27;accordion&#x27;,
    transclude: true,
    replace: false,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/accordion/accordion.html&#x27;;
    }
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive(&#x27;accordionGroup&#x27;, function() {
  return {
    require: &#x27;^accordion&#x27;,         // We need this directive to be inside an accordion
    restrict: &#x27;EA&#x27;,
    transclude: true,              // It transcludes the contents of the directive into the template
    replace: true,                // The element containing the directive will be replaced with the template
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/accordion/accordion-group.html&#x27;;
    },
    scope: {
      heading: &#x27;@&#x27;,               // Interpolate the heading attribute onto this scope
      isOpen: &#x27;=?&#x27;,
      isDisabled: &#x27;=?&#x27;
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      accordionCtrl.addGroup(scope);

      scope.openClass = attrs.openClass || &#x27;panel-open&#x27;;
      scope.panelClass = attrs.panelClass;
      scope.$watch(&#x27;isOpen&#x27;, function(value) {
        element.toggleClass(scope.openClass, value);
        if (value) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function($event) {
        if (!scope.isDisabled) {
          if (!$event || $event.which === 32) {
            scope.isOpen = !scope.isOpen;
          }
        }
      };
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// &lt;accordion-group&gt;
//   &lt;accordion-heading&gt;Heading containing HTML - &lt;img src=&quot;...&quot;&gt;&lt;/accordion-heading&gt;
// &lt;/accordion-group&gt;
.directive(&#x27;accordionHeading&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    transclude: true,   // Grab the contents to be used as the heading
    template: &#x27;&#x27;,       // In effect remove this element!
    replace: true,
    require: &#x27;^accordionGroup&#x27;,
    link: function(scope, element, attr, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// &lt;div class=&quot;accordion-group&quot;&gt;
//   &lt;div class=&quot;accordion-heading&quot; &gt;&lt;a ... accordion-transclude=&quot;heading&quot;&gt;...&lt;/a&gt;&lt;/div&gt;
//   ...
// &lt;/div&gt;
.directive(&#x27;accordionTransclude&#x27;, function() {
  return {
    require: &#x27;^accordionGroup&#x27;,
    link: function(scope, element, attr, controller) {
      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
        if (heading) {
          element.find(&#x27;span&#x27;).html(&#x27;&#x27;);
          element.find(&#x27;span&#x27;).append(heading);
        }
      });
    }
  };
})

;

angular.module(&#x27;ui.bootstrap.alert&#x27;, [])

.controller(&#x27;AlertController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, function($scope, $attrs) {
  $scope.closeable = !!$attrs.close;
  this.close = $scope.close;
}])

.directive(&#x27;alert&#x27;, function() {
  return {
    controller: &#x27;AlertController&#x27;,
    controllerAs: &#x27;alert&#x27;,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/alert/alert.html&#x27;;
    },
    transclude: true,
    replace: true,
    scope: {
      type: &#x27;@&#x27;,
      close: &#x27;&amp;&#x27;
    }
  };
})

.directive(&#x27;dismissOnTimeout&#x27;, [&#x27;$timeout&#x27;, function($timeout) {
  return {
    require: &#x27;alert&#x27;,
    link: function(scope, element, attrs, alertCtrl) {
      $timeout(function() {
        alertCtrl.close();
      }, parseInt(attrs.dismissOnTimeout, 10));
    }
  };
}]);

angular.module(&#x27;ui.bootstrap.bindHtml&#x27;, [])

  .value(&#x27;$bindHtmlUnsafeSuppressDeprecated&#x27;, false)

  .directive(&#x27;bindHtmlUnsafe&#x27;, [&#x27;$log&#x27;, &#x27;$bindHtmlUnsafeSuppressDeprecated&#x27;, function ($log, $bindHtmlUnsafeSuppressDeprecated) {
    return function (scope, element, attr) {
      if (!$bindHtmlUnsafeSuppressDeprecated) {
        $log.warn(&#x27;bindHtmlUnsafe is now deprecated. Use ngBindHtml instead&#x27;);
      }
      element.addClass(&#x27;ng-binding&#x27;).data(&#x27;$binding&#x27;, attr.bindHtmlUnsafe);
      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
        element.html(value || &#x27;&#x27;);
      });
    };
  }]);
angular.module(&#x27;ui.bootstrap.buttons&#x27;, [])

.constant(&#x27;buttonConfig&#x27;, {
  activeClass: &#x27;active&#x27;,
  toggleEvent: &#x27;click&#x27;
})

.controller(&#x27;ButtonsController&#x27;, [&#x27;buttonConfig&#x27;, function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || &#x27;active&#x27;;
  this.toggleEvent = buttonConfig.toggleEvent || &#x27;click&#x27;;
}])

.directive(&#x27;btnRadio&#x27;, function() {
  return {
    require: [&#x27;btnRadio&#x27;, &#x27;ngModel&#x27;],
    controller: &#x27;ButtonsController&#x27;,
    controllerAs: &#x27;buttons&#x27;,
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find(&#x27;input&#x27;).css({display: &#x27;none&#x27;});

      //model -&gt; UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
      };

      //ui-&gt;model
      element.bind(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
})

.directive(&#x27;btnCheckbox&#x27;, [&#x27;$document&#x27;, function($document) {
  return {
    require: [&#x27;btnCheckbox&#x27;, &#x27;ngModel&#x27;],
    controller: &#x27;ButtonsController&#x27;,
    controllerAs: &#x27;button&#x27;,
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find(&#x27;input&#x27;).css({display: &#x27;none&#x27;});

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attributeValue, defaultValue) {
        var val = scope.$eval(attributeValue);
        return angular.isDefined(val) ? val : defaultValue;
      }

      //model -&gt; UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui-&gt;model
      element.bind(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        scope.$apply(function() {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });

      //accessibility
      element.on(&#x27;keypress&#x27;, function(e) {
        if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {
          return;
        }

        scope.$apply(function() {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
}]);

/**
* @ngdoc overview
* @name ui.bootstrap.carousel
*
* @description
* AngularJS version of an image carousel.
*
*/
angular.module(&#x27;ui.bootstrap.carousel&#x27;, [])
.controller(&#x27;CarouselController&#x27;, [&#x27;$scope&#x27;, &#x27;$element&#x27;, &#x27;$interval&#x27;, &#x27;$animate&#x27;, function ($scope, $element, $interval, $animate) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    NEW_ANIMATE = angular.version.minor &gt;= 4,
    NO_TRANSITION = &#x27;uib-noTransition&#x27;,
    SLIDE_DIRECTION = &#x27;uib-slideDirection&#x27;,
    currentIndex = -1,
    currentInterval, isPlaying;
  self.currentSlide = null;

  var destroyed = false;
  /* direction: &quot;prev&quot; or &quot;next&quot; */
  self.select = $scope.select = function(nextSlide, direction) {
    var nextIndex = $scope.indexOfSlide(nextSlide);
    //Decide direction if it&#x27;s not given
    if (direction === undefined) {
      direction = nextIndex &gt; self.getCurrentIndex() ? &#x27;next&#x27; : &#x27;prev&#x27;;
    }
    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (nextSlide &amp;&amp; nextSlide !== self.currentSlide &amp;&amp; !$scope.$currentTransition) {
      goNext(nextSlide, nextIndex, direction);
    }
  };

  function goNext(slide, index, direction) {
    // Scope has been destroyed, stop here.
    if (destroyed) { return; }

    angular.extend(slide, {direction: direction, active: true});
    angular.extend(self.currentSlide || {}, {direction: direction, active: false});
    if ($animate.enabled() &amp;&amp; !$scope.noTransition &amp;&amp; !$scope.$currentTransition &amp;&amp;
      slide.$element &amp;&amp; self.slides.length &gt; 1) {
      slide.$element.data(SLIDE_DIRECTION, slide.direction);
      if (self.currentSlide &amp;&amp; self.currentSlide.$element) {
        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
      }

      $scope.$currentTransition = true;
      if (NEW_ANIMATE) {
        $animate.on(&#x27;addClass&#x27;, slide.$element, function (element, phase) {
          if (phase === &#x27;close&#x27;) {
            $scope.$currentTransition = null;
            $animate.off(&#x27;addClass&#x27;, element);
          }
        });
      } else {
        slide.$element.one(&#x27;$animate:close&#x27;, function closeFn() {
          $scope.$currentTransition = null;
        });
      }
    }

    self.currentSlide = slide;
    currentIndex = index;

    //every time you change slides, reset the timer
    restartTimer();
  }

  $scope.$on(&#x27;$destroy&#x27;, function () {
    destroyed = true;
  });

  function getSlideByIndex(index) {
    if (angular.isUndefined(slides[index].index)) {
      return slides[index];
    }
    var i, len = slides.length;
    for (i = 0; i &lt; slides.length; ++i) {
      if (slides[i].index == index) {
        return slides[i];
      }
    }
  }

  self.getCurrentIndex = function() {
    if (self.currentSlide &amp;&amp; angular.isDefined(self.currentSlide.index)) {
      return +self.currentSlide.index;
    }
    return currentIndex;
  };

  /* Allow outside people to call indexOf on slides array */
  $scope.indexOfSlide = function(slide) {
    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
  };

  $scope.next = function() {
    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

    if (newIndex === 0 &amp;&amp; $scope.noWrap()) {
      $scope.pause();
      return;
    }

    return self.select(getSlideByIndex(newIndex), &#x27;next&#x27;);
  };

  $scope.prev = function() {
    var newIndex = self.getCurrentIndex() - 1 &lt; 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

    if ($scope.noWrap() &amp;&amp; newIndex === slides.length - 1){
      $scope.pause();
      return;
    }

    return self.select(getSlideByIndex(newIndex), &#x27;prev&#x27;);
  };

  $scope.isActive = function(slide) {
     return self.currentSlide === slide;
  };

  $scope.$watch(&#x27;interval&#x27;, restartTimer);
  $scope.$on(&#x27;$destroy&#x27;, resetTimer);

  function restartTimer() {
    resetTimer();
    var interval = +$scope.interval;
    if (!isNaN(interval) &amp;&amp; interval &gt; 0) {
      currentInterval = $interval(timerFn, interval);
    }
  }

  function resetTimer() {
    if (currentInterval) {
      $interval.cancel(currentInterval);
      currentInterval = null;
    }
  }

  function timerFn() {
    var interval = +$scope.interval;
    if (isPlaying &amp;&amp; !isNaN(interval) &amp;&amp; interval &gt; 0 &amp;&amp; slides.length) {
      $scope.next();
    } else {
      $scope.pause();
    }
  }

  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };
  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      resetTimer();
    }
  };

  self.addSlide = function(slide, element) {
    slide.$element = element;
    slides.push(slide);
    //if this is the first slide or the slide is set to active, select it
    if(slides.length === 1 || slide.active) {
      self.select(slides[slides.length-1]);
      if (slides.length == 1) {
        $scope.play();
      }
    } else {
      slide.active = false;
    }
  };

  self.removeSlide = function(slide) {
    if (angular.isDefined(slide.index)) {
      slides.sort(function(a, b) {
        return +a.index &gt; +b.index;
      });
    }
    //get the index of the slide inside the carousel
    var index = slides.indexOf(slide);
    slides.splice(index, 1);
    if (slides.length &gt; 0 &amp;&amp; slide.active) {
      if (index &gt;= slides.length) {
        self.select(slides[index-1]);
      } else {
        self.select(slides[index]);
      }
    } else if (currentIndex &gt; index) {
      currentIndex--;
    }
    
    //clean the currentSlide when no more slide
    if (slides.length === 0) {
      self.currentSlide = null;
    }
  };

  $scope.$watch(&#x27;noTransition&#x27;, function(noTransition) {
    $element.data(NO_TRANSITION, noTransition);
  });

}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image &#x27;slides&#x27; to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
    &lt;carousel&gt;
      &lt;slide&gt;
        &lt;img src=&quot;http://placekitten.com/150/150&quot; style=&quot;margin:auto;&quot;&gt;
        &lt;div class=&quot;carousel-caption&quot;&gt;
          &lt;p&gt;Beautiful!&lt;/p&gt;
        &lt;/div&gt;
      &lt;/slide&gt;
      &lt;slide&gt;
        &lt;img src=&quot;http://placekitten.com/100/150&quot; style=&quot;margin:auto;&quot;&gt;
        &lt;div class=&quot;carousel-caption&quot;&gt;
          &lt;p&gt;D&#x27;aww!&lt;/p&gt;
        &lt;/div&gt;
      &lt;/slide&gt;
    &lt;/carousel&gt;
  &lt;/file&gt;
  &lt;file name=&quot;demo.css&quot;&gt;
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  &lt;/file&gt;
&lt;/example&gt;
 */
.directive(&#x27;carousel&#x27;, [function() {
  return {
    restrict: &#x27;EA&#x27;,
    transclude: true,
    replace: true,
    controller: &#x27;CarouselController&#x27;,
    controllerAs: &#x27;carousel&#x27;,
    require: &#x27;carousel&#x27;,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/carousel/carousel.html&#x27;;
    },
    scope: {
      interval: &#x27;=&#x27;,
      noTransition: &#x27;=&#x27;,
      noPause: &#x27;=&#x27;,
      noWrap: &#x27;&amp;&#x27;
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 * @param {number=} index The index of the slide. The slides will be sorted by this parameter.
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
&lt;div ng-controller=&quot;CarouselDemoCtrl&quot;&gt;
  &lt;carousel&gt;
    &lt;slide ng-repeat=&quot;slide in slides&quot; active=&quot;slide.active&quot; index=&quot;$index&quot;&gt;
      &lt;img ng-src=&quot;{{slide.image}}&quot; style=&quot;margin:auto;&quot;&gt;
      &lt;div class=&quot;carousel-caption&quot;&gt;
        &lt;h4&gt;Slide {{$index}}&lt;/h4&gt;
        &lt;p&gt;{{slide.text}}&lt;/p&gt;
      &lt;/div&gt;
    &lt;/slide&gt;
  &lt;/carousel&gt;
  Interval, in milliseconds: &lt;input type=&quot;number&quot; ng-model=&quot;myInterval&quot;&gt;
  &lt;br /&gt;Enter a negative number to stop the interval.
&lt;/div&gt;
  &lt;/file&gt;
  &lt;file name=&quot;script.js&quot;&gt;
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
}
  &lt;/file&gt;
  &lt;file name=&quot;demo.css&quot;&gt;
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  &lt;/file&gt;
&lt;/example&gt;
*/

.directive(&#x27;slide&#x27;, function() {
  return {
    require: &#x27;^carousel&#x27;,
    restrict: &#x27;EA&#x27;,
    transclude: true,
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/carousel/slide.html&#x27;;
    },
    scope: {
      active: &#x27;=?&#x27;,
      actual: &#x27;=?&#x27;,
      index: &#x27;=?&#x27;
    },
    link: function (scope, element, attrs, carouselCtrl) {
      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on(&#x27;$destroy&#x27;, function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch(&#x27;active&#x27;, function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
})

.animation(&#x27;.item&#x27;, [
         &#x27;$injector&#x27;, &#x27;$animate&#x27;,
function ($injector, $animate) {
  var NO_TRANSITION = &#x27;uib-noTransition&#x27;,
    SLIDE_DIRECTION = &#x27;uib-slideDirection&#x27;,
    $animateCss = null;

  if ($injector.has(&#x27;$animateCss&#x27;)) {
    $animateCss = $injector.get(&#x27;$animateCss&#x27;);
  }

  function removeClass(element, className, callback) {
    element.removeClass(className);
    if (callback) {
      callback();
    }
  }

  return {
    beforeAddClass: function (element, className, done) {
      // Due to transclusion, noTransition property is on parent&#x27;s scope
      if (className == &#x27;active&#x27; &amp;&amp; element.parent() &amp;&amp;
          !element.parent().data(NO_TRANSITION)) {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction == &#x27;next&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;
        var removeClassFn = removeClass.bind(this, element,
          directionClass + &#x27; &#x27; + direction, done);
        element.addClass(direction);

        if ($animateCss) {
          $animateCss(element, {addClass: directionClass})
            .start()
            .done(removeClassFn);
        } else {
          $animate.addClass(element, directionClass).then(function () {
            if (!stopped) {
              removeClassFn();
            }
            done();
          });
        }

        return function () {
          stopped = true;
        };
      }
      done();
    },
    beforeRemoveClass: function (element, className, done) {
      // Due to transclusion, noTransition property is on parent&#x27;s scope
      if (className === &#x27;active&#x27; &amp;&amp; element.parent() &amp;&amp;
          !element.parent().data(NO_TRANSITION)) {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction == &#x27;next&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;
        var removeClassFn = removeClass.bind(this, element, directionClass, done);

        if ($animateCss) {
          $animateCss(element, {addClass: directionClass})
            .start()
            .done(removeClassFn);
        } else {
          $animate.addClass(element, directionClass).then(function () {
            if (!stopped) {
              removeClassFn();
            }
            done();
          });
        }
        return function () {
          stopped = true;
        };
      }
      done();
    }
  };

}])


;

angular.module(&#x27;ui.bootstrap.dateparser&#x27;, [])

.service(&#x27;dateParser&#x27;, [&#x27;$log&#x27;, &#x27;$locale&#x27;, &#x27;orderByFilter&#x27;, function($log, $locale, orderByFilter) {
  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  this.parsers = {};

  var formatCodeToRegex = {
    &#x27;yyyy&#x27;: {
      regex: &#x27;\\d{4}&#x27;,
      apply: function(value) { this.year = +value; }
    },
    &#x27;yy&#x27;: {
      regex: &#x27;\\d{2}&#x27;,
      apply: function(value) { this.year = +value + 2000; }
    },
    &#x27;y&#x27;: {
      regex: &#x27;\\d{1,4}&#x27;,
      apply: function(value) { this.year = +value; }
    },
    &#x27;MMMM&#x27;: {
      regex: $locale.DATETIME_FORMATS.MONTH.join(&#x27;|&#x27;),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
    },
    &#x27;MMM&#x27;: {
      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join(&#x27;|&#x27;),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
    },
    &#x27;MM&#x27;: {
      regex: &#x27;0[1-9]|1[0-2]&#x27;,
      apply: function(value) { this.month = value - 1; }
    },
    &#x27;M&#x27;: {
      regex: &#x27;[1-9]|1[0-2]&#x27;,
      apply: function(value) { this.month = value - 1; }
    },
    &#x27;dd&#x27;: {
      regex: &#x27;[0-2][0-9]{1}|3[0-1]{1}&#x27;,
      apply: function(value) { this.date = +value; }
    },
    &#x27;d&#x27;: {
      regex: &#x27;[1-2]?[0-9]{1}|3[0-1]{1}&#x27;,
      apply: function(value) { this.date = +value; }
    },
    &#x27;EEEE&#x27;: {
      regex: $locale.DATETIME_FORMATS.DAY.join(&#x27;|&#x27;)
    },
    &#x27;EEE&#x27;: {
      regex: $locale.DATETIME_FORMATS.SHORTDAY.join(&#x27;|&#x27;)
    },
    &#x27;HH&#x27;: {
      regex: &#x27;(?:0|1)[0-9]|2[0-3]&#x27;,
      apply: function(value) { this.hours = +value; }
    },
    &#x27;hh&#x27;: {
      regex: &#x27;0[0-9]|1[0-2]&#x27;,
      apply: function(value) { this.hours = +value; }
    },
    &#x27;H&#x27;: {
      regex: &#x27;1?[0-9]|2[0-3]&#x27;,
      apply: function(value) { this.hours = +value; }
    },
    &#x27;h&#x27;: {
      regex: &#x27;[0-9]|1[0-2]&#x27;,
      apply: function(value) { this.hours = +value; }
    },
    &#x27;mm&#x27;: {
      regex: &#x27;[0-5][0-9]&#x27;,
      apply: function(value) { this.minutes = +value; }
    },
    &#x27;m&#x27;: {
      regex: &#x27;[0-9]|[1-5][0-9]&#x27;,
      apply: function(value) { this.minutes = +value; }
    },
    &#x27;sss&#x27;: {
      regex: &#x27;[0-9][0-9][0-9]&#x27;,
      apply: function(value) { this.milliseconds = +value; }
    },
    &#x27;ss&#x27;: {
      regex: &#x27;[0-5][0-9]&#x27;,
      apply: function(value) { this.seconds = +value; }
    },
    &#x27;s&#x27;: {
      regex: &#x27;[0-9]|[1-5][0-9]&#x27;,
      apply: function(value) { this.seconds = +value; }
    },
    &#x27;a&#x27;: {
      regex: $locale.DATETIME_FORMATS.AMPMS.join(&#x27;|&#x27;),
      apply: function(value) {
        if (this.hours === 12) {
          this.hours = 0;
        }

        if (value === &#x27;PM&#x27;) {
          this.hours += 12;
        }
      }
    }
  };

  function createParser(format) {
    var map = [], regex = format.split(&#x27;&#x27;);

    angular.forEach(formatCodeToRegex, function(data, code) {
      var index = format.indexOf(code);

      if (index &gt; -1) {
        format = format.split(&#x27;&#x27;);

        regex[index] = &#x27;(&#x27; + data.regex + &#x27;)&#x27;;
        format[index] = &#x27;$&#x27;; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + code.length; i &lt; n; i++) {
          regex[i] = &#x27;&#x27;;
          format[i] = &#x27;$&#x27;;
        }
        format = format.join(&#x27;&#x27;);

        map.push({ index: index, apply: data.apply });
      }
    });

    return {
      regex: new RegExp(&#x27;^&#x27; + regex.join(&#x27;&#x27;) + &#x27;$&#x27;),
      map: orderByFilter(map, &#x27;index&#x27;)
    };
  }

  this.parse = function(input, format, baseDate) {
    if (!angular.isString(input) || !format) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;
    format = format.replace(SPECIAL_CHARACTERS_REGEXP, &#x27;\\$&amp;&#x27;);

    if (!this.parsers[format]) {
      this.parsers[format] = createParser(format);
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex);

    if (results &amp;&amp; results.length) {
      var fields, dt;
      if (angular.isDate(baseDate) &amp;&amp; !isNaN(baseDate.getTime())) {
        fields = {
          year: baseDate.getFullYear(),
          month: baseDate.getMonth(),
          date: baseDate.getDate(),
          hours: baseDate.getHours(),
          minutes: baseDate.getMinutes(),
          seconds: baseDate.getSeconds(),
          milliseconds: baseDate.getMilliseconds()
        };
      } else {
        if (baseDate) {
          $log.warn(&#x27;dateparser:&#x27;, &#x27;baseDate is not a valid date&#x27;);
        }
        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
      }

      for (var i = 1, n = results.length; i &lt; n; i++) {
        var mapper = map[i-1];
        if (mapper.apply) {
          mapper.apply.call(fields, results[i]);
        }
      }

      if (isValid(fields.year, fields.month, fields.date)) {
        dt = new Date(fields.year, fields.month, fields.date,
          fields.hours, fields.minutes, fields.seconds,
          fields.milliseconds || 0);
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if (date &lt; 1) {
      return false;
    }

    if (month === 1 &amp;&amp; date &gt; 28) {
      return date === 29 &amp;&amp; ((year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0);
    }

    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return date &lt; 31;
    }

    return true;
  }
}]);

angular.module(&#x27;ui.bootstrap.position&#x27;, [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory(&#x27;$position&#x27;, [&#x27;$document&#x27;, &#x27;$window&#x27;, function($document, $window) {
    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, &#x27;position&#x27;) || &#x27;static&#x27; ) === &#x27;static&#x27;;
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function(element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent &amp;&amp; offsetParent !== docDomEl &amp;&amp; isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery&#x27;s position function:
       * http://api.jquery.com/position/
       */
      position: function(element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop(&#x27;offsetWidth&#x27;),
          height: boundingClientRect.height || element.prop(&#x27;offsetHeight&#x27;),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery&#x27;s offset function:
       * http://api.jquery.com/offset/
       */
      offset: function(element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop(&#x27;offsetWidth&#x27;),
          height: boundingClientRect.height || element.prop(&#x27;offsetHeight&#x27;),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
        };
      },

      /**
       * Provides coordinates for the targetEl in relation to hostEl
       */
      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
        var positionStrParts = positionStr.split(&#x27;-&#x27;);
        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || &#x27;center&#x27;;

        var hostElPos,
          targetElWidth,
          targetElHeight,
          targetElPos;

        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);

        targetElWidth = targetEl.prop(&#x27;offsetWidth&#x27;);
        targetElHeight = targetEl.prop(&#x27;offsetHeight&#x27;);

        var shiftWidth = {
          center: function() {
            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
          },
          left: function() {
            return hostElPos.left;
          },
          right: function() {
            return hostElPos.left + hostElPos.width;
          }
        };

        var shiftHeight = {
          center: function() {
            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
          },
          top: function() {
            return hostElPos.top;
          },
          bottom: function() {
            return hostElPos.top + hostElPos.height;
          }
        };

        switch (pos0) {
          case &#x27;right&#x27;:
            targetElPos = {
              top: shiftHeight[pos1](),
              left: shiftWidth[pos0]()
            };
            break;
          case &#x27;left&#x27;:
            targetElPos = {
              top: shiftHeight[pos1](),
              left: hostElPos.left - targetElWidth
            };
            break;
          case &#x27;bottom&#x27;:
            targetElPos = {
              top: shiftHeight[pos0](),
              left: shiftWidth[pos1]()
            };
            break;
          default:
            targetElPos = {
              top: hostElPos.top - targetElHeight,
              left: shiftWidth[pos1]()
            };
            break;
        }

        return targetElPos;
      }
    };
  }]);

angular.module(&#x27;ui.bootstrap.datepicker&#x27;, [&#x27;ui.bootstrap.dateparser&#x27;, &#x27;ui.bootstrap.position&#x27;])

.value(&#x27;$datepickerSuppressError&#x27;, false)

.constant(&#x27;datepickerConfig&#x27;, {
  formatDay: &#x27;dd&#x27;,
  formatMonth: &#x27;MMMM&#x27;,
  formatYear: &#x27;yyyy&#x27;,
  formatDayHeader: &#x27;EEE&#x27;,
  formatDayTitle: &#x27;MMMM yyyy&#x27;,
  formatMonthTitle: &#x27;yyyy&#x27;,
  datepickerMode: &#x27;day&#x27;,
  minMode: &#x27;day&#x27;,
  maxMode: &#x27;year&#x27;,
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null,
  shortcutPropagation: false
})

.controller(&#x27;DatepickerController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;$parse&#x27;, &#x27;$interpolate&#x27;, &#x27;$log&#x27;, &#x27;dateFilter&#x27;, &#x27;datepickerConfig&#x27;, &#x27;$datepickerSuppressError&#x27;, function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  // Modes chain
  this.modes = [&#x27;day&#x27;, &#x27;month&#x27;, &#x27;year&#x27;];

  // Configuration attributes
  angular.forEach([&#x27;formatDay&#x27;, &#x27;formatMonth&#x27;, &#x27;formatYear&#x27;, &#x27;formatDayHeader&#x27;, &#x27;formatDayTitle&#x27;, &#x27;formatMonthTitle&#x27;,
                   &#x27;showWeeks&#x27;, &#x27;startingDay&#x27;, &#x27;yearRange&#x27;, &#x27;shortcutPropagation&#x27;], function(key, index) {
    self[key] = angular.isDefined($attrs[key]) ? (index &lt; 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
  });

  // Watchable date attributes
  angular.forEach([&#x27;minDate&#x27;, &#x27;maxDate&#x27;], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  angular.forEach([&#x27;minMode&#x27;, &#x27;maxMode&#x27;], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = angular.isDefined(value) ? value : $attrs[key];
        $scope[key] = self[key];
        if ((key == &#x27;minMode&#x27; &amp;&amp; self.modes.indexOf($scope.datepickerMode) &lt; self.modes.indexOf(self[key])) || (key == &#x27;maxMode&#x27; &amp;&amp; self.modes.indexOf($scope.datepickerMode) &gt; self.modes.indexOf(self[key]))) {
          $scope.datepickerMode = self[key];
        }
      });
    } else {
      self[key] = datepickerConfig[key] || null;
      $scope[key] = self[key];
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.uniqueId = &#x27;datepicker-&#x27; + $scope.$id + &#x27;-&#x27; + Math.floor(Math.random() * 10000);

  if (angular.isDefined($attrs.initDate)) {
    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
    $scope.$parent.$watch($attrs.initDate, function(initDate) {
      if (initDate &amp;&amp; (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
        self.activeDate = initDate;
        self.refreshView();
      }
    });
  } else {
    this.activeDate = new Date();
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if (ngModelCtrl.$viewValue) {
      var date = new Date(ngModelCtrl.$viewValue),
          isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = date;
      } else if (!$datepickerSuppressError) {
        $log.error(&#x27;Datepicker directive: &quot;ng-model&quot; value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.&#x27;);
      }
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if (this.element) {
      this._refreshView();

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      ngModelCtrl.$setValidity(&#x27;dateDisabled&#x27;, !date || (this.element &amp;&amp; !this.isDisabled(date)));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model &amp;&amp; this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0,
      customClass: this.customClass(date)
    };
  };

  this.isDisabled = function(date) {
    return ((this.minDate &amp;&amp; this.compare(date, this.minDate) &lt; 0) || (this.maxDate &amp;&amp; this.compare(date, this.maxDate) &gt; 0) || ($attrs.dateDisabled &amp;&amp; $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
  };

  this.customClass = function(date) {
    return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length &gt; 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  // Fix a hard-reprodusible bug with timezones
  // The bug depends on OS, browser, current timezone and current date
  // i.e.
  // var date = new Date(2014, 0, 1);
  // console.log(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours());
  // can result in &quot;2013 11 31 23&quot; because of the bug.
  this.fixTimeZone = function(date) {
    var hours = date.getHours();
    date.setHours(hours === 23 ? hours + 2 : 0);
  };

  $scope.select = function(date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }
  };

  $scope.move = function(direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function(direction) {
    direction = direction || 1;

    if (($scope.datepickerMode === self.maxMode &amp;&amp; direction === 1) || ($scope.datepickerMode === self.minMode &amp;&amp; direction === -1)) {
      return;
    }

    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
  };

  // Key event mapper
  $scope.keys = { 13: &#x27;enter&#x27;, 32: &#x27;space&#x27;, 33: &#x27;pageup&#x27;, 34: &#x27;pagedown&#x27;, 35: &#x27;end&#x27;, 36: &#x27;home&#x27;, 37: &#x27;left&#x27;, 38: &#x27;up&#x27;, 39: &#x27;right&#x27;, 40: &#x27;down&#x27; };

  var focusElement = function() {
    self.element[0].focus();
  };

  // Listen for focus requests from popup directive
  $scope.$on(&#x27;datepicker.focus&#x27;, focusElement);

  $scope.keydown = function(evt) {
    var key = $scope.keys[evt.which];

    if (!key || evt.shiftKey || evt.altKey) {
      return;
    }

    evt.preventDefault();
    if (!self.shortcutPropagation) {
      evt.stopPropagation();
    }

    if (key === &#x27;enter&#x27; || key === &#x27;space&#x27;) {
      if (self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
      focusElement();
    } else if (evt.ctrlKey &amp;&amp; (key === &#x27;up&#x27; || key === &#x27;down&#x27;)) {
      $scope.toggleMode(key === &#x27;up&#x27; ? 1 : -1);
      focusElement();
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };
}])

.directive(&#x27;datepicker&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/datepicker/datepicker.html&#x27;;
    },
    scope: {
      datepickerMode: &#x27;=?&#x27;,
      dateDisabled: &#x27;&amp;&#x27;,
      customClass: &#x27;&amp;&#x27;,
      shortcutPropagation: &#x27;&amp;?&#x27;
    },
    require: [&#x27;datepicker&#x27;, &#x27;^ngModel&#x27;],
    controller: &#x27;DatepickerController&#x27;,
    controllerAs: &#x27;datepicker&#x27;,
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      datepickerCtrl.init(ngModelCtrl);
    }
  };
})

.directive(&#x27;daypicker&#x27;, [&#x27;dateFilter&#x27;, function(dateFilter) {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: &#x27;template/datepicker/day.html&#x27;,
    require: &#x27;^datepicker&#x27;,
    link: function(scope, element, attrs, ctrl) {
      scope.showWeeks = ctrl.showWeeks;

      ctrl.step = { months: 1 };
      ctrl.element = element;

      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function getDaysInMonth(year, month) {
        return ((month === 1) &amp;&amp; (year % 4 === 0) &amp;&amp; ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
      }

      function getDates(startDate, n) {
        var dates = new Array(n), current = new Date(startDate), i = 0, date;
        while (i &lt; n) {
          date = new Date(current);
          ctrl.fixTimeZone(date);
          dates[i++] = date;
          current.setDate(current.getDate() + 1);
        }
        return dates;
      }

      ctrl._refreshView = function() {
        var year = ctrl.activeDate.getFullYear(),
          month = ctrl.activeDate.getMonth(),
          firstDayOfMonth = new Date(year, month, 1),
          difference = ctrl.startingDay - firstDayOfMonth.getDay(),
          numDisplayedFromPreviousMonth = (difference &gt; 0) ? 7 - difference : - difference,
          firstDate = new Date(firstDayOfMonth);

        if (numDisplayedFromPreviousMonth &gt; 0) {
          firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        }

        // 42 is the number of days on a six-month calendar
        var days = getDates(firstDate, 42);
        for (var i = 0; i &lt; 42; i ++) {
          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + &#x27;-&#x27; + i
          });
        }

        scope.labels = new Array(7);
        for (var j = 0; j &lt; 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
            full: dateFilter(days[j].date, &#x27;EEEE&#x27;)
          };
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
        scope.rows = ctrl.split(days, 7);

        if (scope.showWeeks) {
          scope.weekNumbers = [];
          var thursdayIndex = (4 + 7 - ctrl.startingDay) % 7,
              numWeeks = scope.rows.length;
          for (var curWeek = 0; curWeek &lt; numWeeks; curWeek++) {
            scope.weekNumbers.push(
              getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
          }
        }
      };

      ctrl.compare = function(date1, date2) {
        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }

      ctrl.handleKeyDown = function(key, evt) {
        var date = ctrl.activeDate.getDate();

        if (key === &#x27;left&#x27;) {
          date = date - 1;   // up
        } else if (key === &#x27;up&#x27;) {
          date = date - 7;   // down
        } else if (key === &#x27;right&#x27;) {
          date = date + 1;   // down
        } else if (key === &#x27;down&#x27;) {
          date = date + 7;
        } else if (key === &#x27;pageup&#x27; || key === &#x27;pagedown&#x27;) {
          var month = ctrl.activeDate.getMonth() + (key === &#x27;pageup&#x27; ? - 1 : 1);
          ctrl.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
        } else if (key === &#x27;home&#x27;) {
          date = 1;
        } else if (key === &#x27;end&#x27;) {
          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
        }
        ctrl.activeDate.setDate(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive(&#x27;monthpicker&#x27;, [&#x27;dateFilter&#x27;, function(dateFilter) {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: &#x27;template/datepicker/month.html&#x27;,
    require: &#x27;^datepicker&#x27;,
    link: function(scope, element, attrs, ctrl) {
      ctrl.step = { years: 1 };
      ctrl.element = element;

      ctrl._refreshView = function() {
        var months = new Array(12),
            year = ctrl.activeDate.getFullYear(),
            date;

        for (var i = 0; i &lt; 12; i++) {
          date = new Date(year, i, 1);
          ctrl.fixTimeZone(date);
          months[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatMonth), {
            uid: scope.uniqueId + &#x27;-&#x27; + i
          });
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
        scope.rows = ctrl.split(months, 3);
      };

      ctrl.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
      };

      ctrl.handleKeyDown = function(key, evt) {
        var date = ctrl.activeDate.getMonth();

        if (key === &#x27;left&#x27;) {
          date = date - 1;   // up
        } else if (key === &#x27;up&#x27;) {
          date = date - 3;   // down
        } else if (key === &#x27;right&#x27;) {
          date = date + 1;   // down
        } else if (key === &#x27;down&#x27;) {
          date = date + 3;
        } else if (key === &#x27;pageup&#x27; || key === &#x27;pagedown&#x27;) {
          var year = ctrl.activeDate.getFullYear() + (key === &#x27;pageup&#x27; ? - 1 : 1);
          ctrl.activeDate.setFullYear(year);
        } else if (key === &#x27;home&#x27;) {
          date = 0;
        } else if (key === &#x27;end&#x27;) {
          date = 11;
        }
        ctrl.activeDate.setMonth(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive(&#x27;yearpicker&#x27;, [&#x27;dateFilter&#x27;, function(dateFilter) {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: &#x27;template/datepicker/year.html&#x27;,
    require: &#x27;^datepicker&#x27;,
    link: function(scope, element, attrs, ctrl) {
      var range = ctrl.yearRange;

      ctrl.step = { years: range };
      ctrl.element = element;

      function getStartingYear( year ) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }

      ctrl._refreshView = function() {
        var years = new Array(range), date;

        for (var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i &lt; range; i++) {
          date = new Date(start + i, 0, 1);
          ctrl.fixTimeZone(date);
          years[i] = angular.extend(ctrl.createDateObject(date, ctrl.formatYear), {
            uid: scope.uniqueId + &#x27;-&#x27; + i
          });
        }

        scope.title = [years[0].label, years[range - 1].label].join(&#x27; - &#x27;);
        scope.rows = ctrl.split(years, 5);
      };

      ctrl.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };

      ctrl.handleKeyDown = function(key, evt) {
        var date = ctrl.activeDate.getFullYear();

        if (key === &#x27;left&#x27;) {
          date = date - 1;   // up
        } else if (key === &#x27;up&#x27;) {
          date = date - 5;   // down
        } else if (key === &#x27;right&#x27;) {
          date = date + 1;   // down
        } else if (key === &#x27;down&#x27;) {
          date = date + 5;
        } else if (key === &#x27;pageup&#x27; || key === &#x27;pagedown&#x27;) {
          date += (key === &#x27;pageup&#x27; ? - 1 : 1) * ctrl.step.years;
        } else if (key === &#x27;home&#x27;) {
          date = getStartingYear(ctrl.activeDate.getFullYear());
        } else if (key === &#x27;end&#x27;) {
          date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1;
        }
        ctrl.activeDate.setFullYear(date);
      };

      ctrl.refreshView();
    }
  };
}])

.constant(&#x27;datepickerPopupConfig&#x27;, {
  datepickerPopup: &#x27;yyyy-MM-dd&#x27;,
  datepickerPopupTemplateUrl: &#x27;template/datepicker/popup.html&#x27;,
  datepickerTemplateUrl: &#x27;template/datepicker/datepicker.html&#x27;,
  html5Types: {
    date: &#x27;yyyy-MM-dd&#x27;,
    &#x27;datetime-local&#x27;: &#x27;yyyy-MM-ddTHH:mm:ss.sss&#x27;,
    &#x27;month&#x27;: &#x27;yyyy-MM&#x27;
  },
  currentText: &#x27;Today&#x27;,
  clearText: &#x27;Clear&#x27;,
  closeText: &#x27;Done&#x27;,
  closeOnDateSelection: true,
  appendToBody: false,
  showButtonBar: true,
  onOpenFocus: true
})

.directive(&#x27;datepickerPopup&#x27;, [&#x27;$compile&#x27;, &#x27;$parse&#x27;, &#x27;$document&#x27;, &#x27;$rootScope&#x27;, &#x27;$position&#x27;, &#x27;dateFilter&#x27;, &#x27;dateParser&#x27;, &#x27;datepickerPopupConfig&#x27;, &#x27;$timeout&#x27;,
function($compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
  return {
    restrict: &#x27;EA&#x27;,
    require: &#x27;ngModel&#x27;,
    scope: {
      isOpen: &#x27;=?&#x27;,
      currentText: &#x27;@&#x27;,
      clearText: &#x27;@&#x27;,
      closeText: &#x27;@&#x27;,
      dateDisabled: &#x27;&amp;&#x27;,
      customClass: &#x27;&amp;&#x27;
    },
    link: function(scope, element, attrs, ngModel) {
      var dateFormat,
          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody,
          onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus,
          datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl,
          datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl,
          cache = {};

      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

      scope.getText = function(key) {
        return scope[key + &#x27;Text&#x27;] || datepickerPopupConfig[key + &#x27;Text&#x27;];
      };

      scope.isDisabled = function(date) {
        if (date === &#x27;today&#x27;) {
          date = new Date();
        }

        return ((scope.watchData.minDate &amp;&amp; scope.compare(date, cache.minDate) &lt; 0) ||
          (scope.watchData.maxDate &amp;&amp; scope.compare(date, cache.maxDate) &gt; 0));
      };

      scope.compare = function(date1, date2) {
        return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
      };

      var isHtml5DateInput = false;
      if (datepickerPopupConfig.html5Types[attrs.type]) {
        dateFormat = datepickerPopupConfig.html5Types[attrs.type];
        isHtml5DateInput = true;
      } else {
        dateFormat = attrs.datepickerPopup || datepickerPopupConfig.datepickerPopup;
        attrs.$observe(&#x27;datepickerPopup&#x27;, function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            // Invalidate the $modelValue to ensure that formatters re-run
            // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;

              if (!dateFormat) {
                throw new Error(&#x27;datepickerPopup must have a date format specified.&#x27;);
              }
            }
        });
      }

      if (!dateFormat) {
        throw new Error(&#x27;datepickerPopup must have a date format specified.&#x27;);
      }

      if (isHtml5DateInput &amp;&amp; attrs.datepickerPopup) {
        throw new Error(&#x27;HTML5 date input types do not support custom formats.&#x27;);
      }

      // popup element used to display calendar
      var popupEl = angular.element(&#x27;&lt;div datepicker-popup-wrap&gt;&lt;div datepicker&gt;&lt;/div&gt;&lt;/div&gt;&#x27;);
      popupEl.attr({
        &#x27;ng-model&#x27;: &#x27;date&#x27;,
        &#x27;ng-change&#x27;: &#x27;dateSelection(date)&#x27;,
        &#x27;template-url&#x27;: datepickerPopupTemplateUrl
      });

      function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function($1) { return &#x27;-&#x27; + $1.toLowerCase(); });
      }

      // datepicker element
      var datepickerEl = angular.element(popupEl.children()[0]);
      datepickerEl.attr(&#x27;template-url&#x27;, datepickerTemplateUrl);

      if (isHtml5DateInput) {
        if (attrs.type === &#x27;month&#x27;) {
          datepickerEl.attr(&#x27;datepicker-mode&#x27;, &#x27;&quot;month&quot;&#x27;);
          datepickerEl.attr(&#x27;min-mode&#x27;, &#x27;month&#x27;);
        }
      }

      if (attrs.datepickerOptions) {
        var options = scope.$parent.$eval(attrs.datepickerOptions);
        if (options &amp;&amp; options.initDate) {
          scope.initDate = options.initDate;
          datepickerEl.attr(&#x27;init-date&#x27;, &#x27;initDate&#x27;);
          delete options.initDate;
        }
        angular.forEach(options, function(value, option) {
          datepickerEl.attr( cameltoDash(option), value );
        });
      }

      scope.watchData = {};
      angular.forEach([&#x27;minMode&#x27;, &#x27;maxMode&#x27;, &#x27;minDate&#x27;, &#x27;maxDate&#x27;, &#x27;datepickerMode&#x27;, &#x27;initDate&#x27;, &#x27;shortcutPropagation&#x27;], function(key) {
        if (attrs[key]) {
          var getAttribute = $parse(attrs[key]);
          scope.$parent.$watch(getAttribute, function(value) {
            scope.watchData[key] = value;
            if (key === &#x27;minDate&#x27; || key === &#x27;maxDate&#x27;) {
              cache[key] = new Date(value);
            }
          });
          datepickerEl.attr(cameltoDash(key), &#x27;watchData.&#x27; + key);

          // Propagate changes from datepicker to outside
          if (key === &#x27;datepickerMode&#x27;) {
            var setAttribute = getAttribute.assign;
            scope.$watch(&#x27;watchData.&#x27; + key, function(value, oldvalue) {
              if (angular.isFunction(setAttribute) &amp;&amp; value !== oldvalue) {
                setAttribute(scope.$parent, value);
              }
            });
          }
        }
      });
      if (attrs.dateDisabled) {
        datepickerEl.attr(&#x27;date-disabled&#x27;, &#x27;dateDisabled({ date: date, mode: mode })&#x27;);
      }

      if (attrs.showWeeks) {
        datepickerEl.attr(&#x27;show-weeks&#x27;, attrs.showWeeks);
      }

      if (attrs.customClass) {
        datepickerEl.attr(&#x27;custom-class&#x27;, &#x27;customClass({ date: date, mode: mode })&#x27;);
      }

      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          // presumably timestamp to date object
          viewValue = new Date(viewValue);
        }

        if (!viewValue) {
          return null;
        } else if (angular.isDate(viewValue) &amp;&amp; !isNaN(viewValue)) {
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = dateParser.parse(viewValue, dateFormat, scope.date);
          if (isNaN(date)) {
            return undefined;
          } else {
            return date;
          }
        } else {
          return undefined;
        }
      }

      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;

        if (!attrs.ngRequired &amp;&amp; !value) {
          return true;
        }

        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        } else if (angular.isDate(value) &amp;&amp; !isNaN(value)) {
          return true;
        } else if (angular.isString(value)) {
          var date = dateParser.parse(value, dateFormat);
          return !isNaN(date);
        } else {
          return false;
        }
      }

      if (!isHtml5DateInput) {
        // Internal API to maintain the correct ng-invalid-[key] class
        ngModel.$$parserName = &#x27;date&#x27;;
        ngModel.$validators.date = validator;
        ngModel.$parsers.unshift(parseDate);
        ngModel.$formatters.push(function(value) {
          scope.date = value;
          return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
        });
      } else {
        ngModel.$formatters.push(function(value) {
          scope.date = value;
          return value;
        });
      }

      // Inner change
      scope.dateSelection = function(dt) {
        if (angular.isDefined(dt)) {
          scope.date = dt;
        }
        var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
        element.val(date);
        ngModel.$setViewValue(date);

        if (closeOnDateSelection) {
          scope.isOpen = false;
          element[0].focus();
        }
      };

      // Detect changes in the view from the text box
      ngModel.$viewChangeListeners.push(function() {
        scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
      });

      var documentClickBind = function(event) {
        if (scope.isOpen &amp;&amp; !(element[0].contains(event.target) || popupEl[0].contains(event.target))) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      };

      var inputKeydownBind = function(evt) {
        if (evt.which === 27 &amp;&amp; scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = false;
          });
          element[0].focus();
        } else if (evt.which === 40 &amp;&amp; !scope.isOpen) {
          evt.preventDefault();
          evt.stopPropagation();
          scope.$apply(function() {
            scope.isOpen = true;
          });
        }
      };
      element.bind(&#x27;keydown&#x27;, inputKeydownBind);

      scope.keydown = function(evt) {
        if (evt.which === 27) {
          scope.isOpen = false;
          element[0].focus();
        }
      };

      scope.$watch(&#x27;isOpen&#x27;, function(value) {
        if (value) {
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top = scope.position.top + element.prop(&#x27;offsetHeight&#x27;);

          $timeout(function() {
            if (onOpenFocus) {
              scope.$broadcast(&#x27;datepicker.focus&#x27;);
            }
            $document.bind(&#x27;click&#x27;, documentClickBind);
          }, 0, false);
        } else {
          $document.unbind(&#x27;click&#x27;, documentClickBind);
        }
      });

      scope.select = function(date) {
        if (date === &#x27;today&#x27;) {
          var today = new Date();
          if (angular.isDate(scope.date)) {
            date = new Date(scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        scope.dateSelection(date);
      };

      scope.close = function() {
        scope.isOpen = false;
        element[0].focus();
      };

      var $popup = $compile(popupEl)(scope);
      // Prevent jQuery cache memory leak (template is now redundant after linking)
      popupEl.remove();

      if (appendToBody) {
        $document.find(&#x27;body&#x27;).append($popup);
      } else {
        element.after($popup);
      }

      scope.$on(&#x27;$destroy&#x27;, function() {
        if (scope.isOpen === true) {
          if (!$rootScope.$$phase) {
            scope.$apply(function() {
              scope.isOpen = false;
            });
          }
        }

        $popup.remove();
        element.unbind(&#x27;keydown&#x27;, inputKeydownBind);
        $document.unbind(&#x27;click&#x27;, documentClickBind);
      });
    }
  };
}])

.directive(&#x27;datepickerPopupWrap&#x27;, function() {
  return {
    restrict:&#x27;EA&#x27;,
    replace: true,
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/datepicker/popup.html&#x27;;
    }
  };
});

angular.module(&#x27;ui.bootstrap.dropdown&#x27;, [&#x27;ui.bootstrap.position&#x27;])

.constant(&#x27;dropdownConfig&#x27;, {
  openClass: &#x27;open&#x27;
})

.service(&#x27;dropdownService&#x27;, [&#x27;$document&#x27;, &#x27;$rootScope&#x27;, function($document, $rootScope) {
  var openScope = null;

  this.open = function(dropdownScope) {
    if (!openScope) {
      $document.bind(&#x27;click&#x27;, closeDropdown);
      $document.bind(&#x27;keydown&#x27;, keybindFilter);
    }

    if (openScope &amp;&amp; openScope !== dropdownScope) {
      openScope.isOpen = false;
    }

    openScope = dropdownScope;
  };

  this.close = function(dropdownScope) {
    if (openScope === dropdownScope) {
      openScope = null;
      $document.unbind(&#x27;click&#x27;, closeDropdown);
      $document.unbind(&#x27;keydown&#x27;, keybindFilter);
    }
  };

  var closeDropdown = function(evt) {
    // This method may still be called during the same mouse event that
    // unbound this event handler. So check openScope before proceeding.
    if (!openScope) { return; }

    if (evt &amp;&amp; openScope.getAutoClose() === &#x27;disabled&#x27;)  { return ; }

    var toggleElement = openScope.getToggleElement();
    if (evt &amp;&amp; toggleElement &amp;&amp; toggleElement[0].contains(evt.target)) {
      return;
    }

    var dropdownElement = openScope.getDropdownElement();
    if (evt &amp;&amp; openScope.getAutoClose() === &#x27;outsideClick&#x27; &amp;&amp;
      dropdownElement &amp;&amp; dropdownElement[0].contains(evt.target)) {
      return;
    }

    openScope.isOpen = false;

    if (!$rootScope.$$phase) {
      openScope.$apply();
    }
  };

  var keybindFilter = function(evt) {
    if (evt.which === 27) {
      openScope.focusToggleElement();
      closeDropdown();
    } else if (openScope.isKeynavEnabled() &amp;&amp; /(38|40)/.test(evt.which) &amp;&amp; openScope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      openScope.focusDropdownEntry(evt.which);
    }
  };
}])

.controller(&#x27;DropdownController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;$parse&#x27;, &#x27;dropdownConfig&#x27;, &#x27;dropdownService&#x27;, &#x27;$animate&#x27;, &#x27;$position&#x27;, &#x27;$document&#x27;, &#x27;$compile&#x27;, &#x27;$templateRequest&#x27;, function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate, $position, $document, $compile, $templateRequest) {
  var self = this,
    scope = $scope.$new(), // create a child scope so we are not polluting original one
    templateScope,
    openClass = dropdownConfig.openClass,
    getIsOpen,
    setIsOpen = angular.noop,
    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
    appendToBody = false,
    keynavEnabled = false,
    selectedOption = null,
    body = $document.find(&#x27;body&#x27;);

  this.init = function(element) {
    self.$element = element;

    if ($attrs.isOpen) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
    keynavEnabled = angular.isDefined($attrs.keyboardNav);

    if (appendToBody &amp;&amp; self.dropdownMenu) {
      body.append(self.dropdownMenu);
      body.addClass(&#x27;dropdown&#x27;);
      element.on(&#x27;$destroy&#x27;, function handleDestroyEvent() {
        self.dropdownMenu.remove();
      });
    }
  };

  this.toggle = function(open) {
    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || &#x27;always&#x27;; //or &#x27;outsideClick&#x27; or &#x27;disabled&#x27;
  };

  scope.getElement = function() {
    return self.$element;
  };

  scope.isKeynavEnabled = function() {
    return keynavEnabled;
  };

  scope.focusDropdownEntry = function(keyCode) {
    var elems = self.dropdownMenu ? //If append to body is used.
      (angular.element(self.dropdownMenu).find(&#x27;a&#x27;)) :
      (angular.element(self.$element).find(&#x27;ul&#x27;).eq(0).find(&#x27;a&#x27;));

    switch (keyCode) {
      case (40): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = 0;
        } else {
          self.selectedOption = (self.selectedOption === elems.length -1 ?
            self.selectedOption :
            self.selectedOption + 1);
        }
        break;
      }
      case (38): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = elems.length - 1;
        } else {
          self.selectedOption = self.selectedOption === 0 ?
            0 : self.selectedOption - 1;
        }
        break;
      }
    }
    elems[self.selectedOption].focus();
  };

  scope.getDropdownElement = function() {
    return self.dropdownMenu;
  };

  scope.focusToggleElement = function() {
    if (self.toggleElement) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch(&#x27;isOpen&#x27;, function(isOpen, wasOpen) {
    if (appendToBody &amp;&amp; self.dropdownMenu) {
      var pos = $position.positionElements(self.$element, self.dropdownMenu, &#x27;bottom-left&#x27;, true);
      var css = {
        top: pos.top + &#x27;px&#x27;,
        display: isOpen ? &#x27;block&#x27; : &#x27;none&#x27;
      };

      var rightalign = self.dropdownMenu.hasClass(&#x27;dropdown-menu-right&#x27;);
      if (!rightalign) {
        css.left = pos.left + &#x27;px&#x27;;
        css.right = &#x27;auto&#x27;;
      } else {
        css.left = &#x27;auto&#x27;;
        css.right = (window.innerWidth - (pos.left + self.$element.prop(&#x27;offsetWidth&#x27;))) + &#x27;px&#x27;;
      }

      self.dropdownMenu.css(css);
    }

    var openContainer = appendToBody ? body : self.$element;

    $animate[isOpen ? &#x27;addClass&#x27; : &#x27;removeClass&#x27;](openContainer, openClass).then(function() {
      if (angular.isDefined(isOpen) &amp;&amp; isOpen !== wasOpen) {
        toggleInvoker($scope, { open: !!isOpen });
      }
    });

    if (isOpen) {
      if (self.dropdownMenuTemplateUrl) {
        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
          templateScope = scope.$new();
          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
            var newEl = dropdownElement;
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          });
        });
      }

      scope.focusToggleElement();
      dropdownService.open(scope);
    } else {
      if (self.dropdownMenuTemplateUrl) {
        if (templateScope) {
          templateScope.$destroy();
        }
        var newEl = angular.element(&#x27;&lt;ul class=&quot;dropdown-menu&quot;&gt;&lt;/ul&gt;&#x27;);
        self.dropdownMenu.replaceWith(newEl);
        self.dropdownMenu = newEl;
      }

      dropdownService.close(scope);
      self.selectedOption = null;
    }

    if (angular.isFunction(setIsOpen)) {
      setIsOpen($scope, isOpen);
    }
  });

  $scope.$on(&#x27;$locationChangeSuccess&#x27;, function() {
    if (scope.getAutoClose() !== &#x27;disabled&#x27;) {
      scope.isOpen = false;
    }
  });

  var offDestroy = $scope.$on(&#x27;$destroy&#x27;, function() {
    scope.$destroy();
  });
  scope.$on(&#x27;$destroy&#x27;, offDestroy);
}])

.directive(&#x27;dropdown&#x27;, function() {
  return {
    controller: &#x27;DropdownController&#x27;,
    link: function(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init( element );
      element.addClass(&#x27;dropdown&#x27;);
    }
  };
})

.directive(&#x27;dropdownMenu&#x27;, function() {
  return {
    restrict: &#x27;AC&#x27;,
    require: &#x27;?^dropdown&#x27;,
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl) {
        return;
      }
      var tplUrl = attrs.templateUrl;
      if (tplUrl) {
        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
      }
      if (!dropdownCtrl.dropdownMenu) {
        dropdownCtrl.dropdownMenu = element;
      }
    }
  };
})

.directive(&#x27;keyboardNav&#x27;, function() {
  return {
    restrict: &#x27;A&#x27;,
    require: &#x27;?^dropdown&#x27;,
    link: function (scope, element, attrs, dropdownCtrl) {

      element.bind(&#x27;keydown&#x27;, function(e) {
        if ([38, 40].indexOf(e.which) !== -1) {
          e.preventDefault();
          e.stopPropagation();

          var elems = dropdownCtrl.dropdownMenu.find(&#x27;a&#x27;);

          switch (e.which) {
            case (40): { // Down
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = 0;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?
                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
              }
              break;
            }
            case (38): { // Up
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = elems.length - 1;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?
                  0 : dropdownCtrl.selectedOption - 1;
              }
              break;
            }
          }
          elems[dropdownCtrl.selectedOption].focus();
        }
      });
    }
  };
})

.directive(&#x27;dropdownToggle&#x27;, function() {
  return {
    require: &#x27;?^dropdown&#x27;,
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl) {
        return;
      }

      element.addClass(&#x27;dropdown-toggle&#x27;);

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if (!element.hasClass(&#x27;disabled&#x27;) &amp;&amp; !attrs.disabled) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind(&#x27;click&#x27;, toggleDropdown);

      // WAI-ARIA
      element.attr({ &#x27;aria-haspopup&#x27;: true, &#x27;aria-expanded&#x27;: false });
      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {
        element.attr(&#x27;aria-expanded&#x27;, !!isOpen);
      });

      scope.$on(&#x27;$destroy&#x27;, function() {
        element.unbind(&#x27;click&#x27;, toggleDropdown);
      });
    }
  };
});

angular.module(&#x27;ui.bootstrap.modal&#x27;, [])

/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory(&#x27;$$stackedMap&#x27;, function() {
    return {
      createNew: function() {
        var stack = [];

        return {
          add: function(key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function(key) {
            for (var i = 0; i &lt; stack.length; i++) {
              if (key == stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i &lt; stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function() {
            return stack[stack.length - 1];
          },
          remove: function(key) {
            var idx = -1;
            for (var i = 0; i &lt; stack.length; i++) {
              if (key == stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function() {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function() {
            return stack.length;
          }
        };
      }
    };
  })

/**
 * A helper, internal data structure that stores all references attached to key
 */
  .factory(&#x27;$$multiMap&#x27;, function() {
    return {
      createNew: function() {
        var map = {};

        return {
          entries: function() {
            return Object.keys(map).map(function(key) {
              return {
                key: key,
                value: map[key]
              };
            });
          },
          get: function(key) {
            return map[key];
          },
          hasKey: function(key) {
            return !!map[key];
          },
          keys: function() {
            return Object.keys(map);
          },
          put: function(key, value) {
            if (!map[key]) {
              map[key] = [];
            }

            map[key].push(value);
          },
          remove: function(key, value) {
            var values = map[key];

            if (!values) {
              return;
            }

            var idx = values.indexOf(value);

            if (idx !== -1) {
              values.splice(idx, 1);
            }

            if (!values.length) {
              delete map[key];
            }
          }
        };
      }
    };
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive(&#x27;modalBackdrop&#x27;, [
           &#x27;$animate&#x27;, &#x27;$injector&#x27;, &#x27;$modalStack&#x27;,
  function($animate ,  $injector,   $modalStack) {
    var $animateCss = null;

    if ($injector.has(&#x27;$animateCss&#x27;)) {
      $animateCss = $injector.get(&#x27;$animateCss&#x27;);
    }

    return {
      restrict: &#x27;EA&#x27;,
      replace: true,
      templateUrl: &#x27;template/modal/backdrop.html&#x27;,
      compile: function(tElement, tAttrs) {
        tElement.addClass(tAttrs.backdropClass);
        return linkFn;
      }
    };

    function linkFn(scope, element, attrs) {
      if (attrs.modalInClass) {
        if ($animateCss) {
          $animateCss(element, {
            addClass: attrs.modalInClass
          }).start();
        } else {
          $animate.addClass(element, attrs.modalInClass);
        }

        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
          var done = setIsAsync();
          if ($animateCss) {
            $animateCss(element, {
              removeClass: attrs.modalInClass
            }).start().then(done);
          } else {
            $animate.removeClass(element, attrs.modalInClass).then(done);
          }
        });
      }
    }
  }])

  .directive(&#x27;modalWindow&#x27;, [
           &#x27;$modalStack&#x27;, &#x27;$q&#x27;, &#x27;$animate&#x27;, &#x27;$injector&#x27;,
  function($modalStack ,  $q ,  $animate,   $injector) {
    var $animateCss = null;

    if ($injector.has(&#x27;$animateCss&#x27;)) {
      $animateCss = $injector.get(&#x27;$animateCss&#x27;);
    }

    return {
      restrict: &#x27;EA&#x27;,
      scope: {
        index: &#x27;@&#x27;
      },
      replace: true,
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || &#x27;template/modal/window.html&#x27;;
      },
      link: function(scope, element, attrs) {
        element.addClass(attrs.windowClass || &#x27;&#x27;);
        scope.size = attrs.size;

        scope.close = function(evt) {
          var modal = $modalStack.getTop();
          if (modal &amp;&amp; modal.value.backdrop &amp;&amp; modal.value.backdrop !== &#x27;static&#x27; &amp;&amp; (evt.target === evt.currentTarget)) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, &#x27;backdrop click&#x27;);
          }
        };

        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
        // We can detect that by using this property in the template associated with this directive and then use
        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
        scope.$isRendered = true;

        // Deferred object that will be resolved when this modal is render.
        var modalRenderDeferObj = $q.defer();
        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal&#x27;s template.
        attrs.$observe(&#x27;modalRender&#x27;, function(value) {
          if (value == &#x27;true&#x27;) {
            modalRenderDeferObj.resolve();
          }
        });

        modalRenderDeferObj.promise.then(function() {
          var animationPromise = null;

          if (attrs.modalInClass) {
            if ($animateCss) {
              animationPromise = $animateCss(element, {
                addClass: attrs.modalInClass
              }).start();
            } else {
              animationPromise = $animate.addClass(element, attrs.modalInClass);
            }

            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
              var done = setIsAsync();
              if ($animateCss) {
                $animateCss(element, {
                  removeClass: attrs.modalInClass
                }).start().then(done);
              } else {
                $animate.removeClass(element, attrs.modalInClass).then(done);
              }
            });
          }


          $q.when(animationPromise).then(function() {
            var inputsWithAutofocus = element[0].querySelectorAll(&#x27;[autofocus]&#x27;);
            /**
             * Auto-focusing of a freshly-opened modal element causes any child elements
             * with the autofocus attribute to lose focus. This is an issue on touch
             * based devices which will show and then hide the onscreen keyboard.
             * Attempts to refocus the autofocus element via JavaScript will not reopen
             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
             * the modal element if the modal does not contain an autofocus element.
             */
            if (inputsWithAutofocus.length) {
              inputsWithAutofocus[0].focus();
            } else {
              element[0].focus();
            }
          });

          // Notify {@link $modalStack} that modal is rendered.
          var modal = $modalStack.getTop();
          if (modal) {
            $modalStack.modalRendered(modal.key);
          }
        });
      }
    };
  }])

  .directive(&#x27;modalAnimationClass&#x27;, [
    function () {
      return {
        compile: function(tElement, tAttrs) {
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.modalAnimationClass);
          }
        }
      };
    }])

  .directive(&#x27;modalTransclude&#x27;, function() {
    return {
      link: function($scope, $element, $attrs, controller, $transclude) {
        $transclude($scope.$parent, function(clone) {
          $element.empty();
          $element.append(clone);
        });
      }
    };
  })

  .factory(&#x27;$modalStack&#x27;, [
             &#x27;$animate&#x27;, &#x27;$timeout&#x27;, &#x27;$document&#x27;, &#x27;$compile&#x27;, &#x27;$rootScope&#x27;,
             &#x27;$q&#x27;,
             &#x27;$injector&#x27;,
             &#x27;$$multiMap&#x27;,
             &#x27;$$stackedMap&#x27;,
    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,
              $q,
              $injector,
              $$multiMap,
              $$stackedMap) {
      var $animateCss = null;

      if ($injector.has(&#x27;$animateCss&#x27;)) {
        $animateCss = $injector.get(&#x27;$animateCss&#x27;);
      }

      var OPENED_MODAL_CLASS = &#x27;modal-open&#x27;;

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: &#x27;modal.stack.now-closing&#x27;
      };

      //Modal focus behavior
      var focusableElementList;
      var focusIndex = 0;
      var tababbleSelector = &#x27;a[href], area[href], input:not([disabled]), &#x27; +
        &#x27;button:not([disabled]),select:not([disabled]), textarea:not([disabled]), &#x27; +
        &#x27;iframe, object, embed, *[tabindex], *[contenteditable=true]&#x27;;

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i &lt; opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var body = $document.find(&#x27;body&#x27;).eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;

        //clean up the stack
        openedWindows.remove(modalInstance);

        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
        });
        checkRemoveBackdrop();

        //move focus to specified element if available, or else to body
        if (elementToReceiveFocus &amp;&amp; elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else {
          body.focus();
        }
      }

      function checkRemoveBackdrop() {
          //remove backdrop if no longer needed
          if (backdropDomEl &amp;&amp; backdropIndex() == -1) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, function() {
              backdropScopeRef = null;
            });
            backdropDomEl = undefined;
            backdropScope = undefined;
          }
      }

      function removeAfterAnimate(domEl, scope, done) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }

          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

        // Note that it&#x27;s intentional that asyncPromise might be null.
        // That&#x27;s when setIsAsync has not been called during the
        // NOW_CLOSING_EVENT broadcast.
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          if ($animateCss) {
            $animateCss(domEl, {
              event: &#x27;leave&#x27;
            }).start().then(function() {
              domEl.remove();
            });
          } else {
            $animate.leave(domEl);
          }
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }

      $document.bind(&#x27;keydown&#x27;, function(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }

        var modal = openedWindows.top();
        if (modal &amp;&amp; modal.value.keyboard) {
          switch (evt.which){
            case 27: {
              evt.preventDefault();
              $rootScope.$apply(function() {
                $modalStack.dismiss(modal.key, &#x27;escape key press&#x27;);
              });
              break;
            }
            case 9: {
              $modalStack.loadFocusElementList(modal);
              var focusChanged = false;
              if (evt.shiftKey) {
                if ($modalStack.isFocusInFirstItem(evt)) {
                  focusChanged = $modalStack.focusLastFocusableElement();
                }
              } else {
                if ($modalStack.isFocusInLastItem(evt)) {
                  focusChanged = $modalStack.focusFirstFocusableElement();
                }
              }

              if (focusChanged) {
                evt.preventDefault();
                evt.stopPropagation();
              }
              break;
            }
          }
        }
      });

      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass
        });

        openedClasses.put(modalBodyClass, modalInstance);

        var body = $document.find(&#x27;body&#x27;).eq(0),
            currBackdropIndex = backdropIndex();

        if (currBackdropIndex &gt;= 0 &amp;&amp; !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.index = currBackdropIndex;
          var angularBackgroundDomEl = angular.element(&#x27;&lt;div modal-backdrop=&quot;modal-backdrop&quot;&gt;&lt;/div&gt;&#x27;);
          angularBackgroundDomEl.attr(&#x27;backdrop-class&#x27;, modal.backdropClass);
          if (modal.animation) {
            angularBackgroundDomEl.attr(&#x27;modal-animation&#x27;, &#x27;true&#x27;);
          }
          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
          body.append(backdropDomEl);
        }

        var angularDomEl = angular.element(&#x27;&lt;div modal-window=&quot;modal-window&quot;&gt;&lt;/div&gt;&#x27;);
        angularDomEl.attr({
          &#x27;template-url&#x27;: modal.windowTemplateUrl,
          &#x27;window-class&#x27;: modal.windowClass,
          &#x27;size&#x27;: modal.size,
          &#x27;index&#x27;: openedWindows.length() - 1,
          &#x27;animate&#x27;: &#x27;animate&#x27;
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr(&#x27;modal-animation&#x27;, &#x27;true&#x27;);
        }

        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        body.append(modalDomEl);
        body.addClass(modalBodyClass);

        $modalStack.clearFocusListCache();
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
          return !modalWindow.value.modalScope.$broadcast(&#x27;modal.closing&#x27;, resultOrReason, closing).defaultPrevented;
      }

      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow &amp;&amp; broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow &amp;&amp; broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal &amp;&amp; this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function() {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      $modalStack.focusFirstFocusableElement = function() {
        if (focusableElementList.length &gt; 0) {
          focusableElementList[0].focus();
          return true;
        }
        return false;
      };
      $modalStack.focusLastFocusableElement = function() {
        if (focusableElementList.length &gt; 0) {
          focusableElementList[focusableElementList.length - 1].focus();
          return true;
        }
        return false;
      };

      $modalStack.isFocusInFirstItem = function(evt) {
        if (focusableElementList.length &gt; 0) {
          return (evt.target || evt.srcElement) == focusableElementList[0];
        }
        return false;
      };

      $modalStack.isFocusInLastItem = function(evt) {
        if (focusableElementList.length &gt; 0) {
          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];
        }
        return false;
      };

      $modalStack.clearFocusListCache = function() {
        focusableElementList = [];
        focusIndex = 0;
      };

      $modalStack.loadFocusElementList = function(modalWindow) {
        if (focusableElementList === undefined || !focusableElementList.length0) {
          if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 &amp;&amp; modalDomE1.length) {
              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
            }
          }
        }
      };

      return $modalStack;
    }])

  .provider(&#x27;$modal&#x27;, function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true, //can also be false or &#x27;static&#x27;
        keyboard: true
      },
      $get: [&#x27;$injector&#x27;, &#x27;$rootScope&#x27;, &#x27;$q&#x27;, &#x27;$templateRequest&#x27;, &#x27;$controller&#x27;, &#x27;$modalStack&#x27;,
        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
          }

          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function(value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              } else if (angular.isString(value)) {
                promisesArr.push($q.when($injector.get(value)));
              } else {
                promisesArr.push($q.when(value));
              }
            });
            return promisesArr;
          }

          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };

          $modal.open = function (modalOptions) {

            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function (result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};

            //verify options
            if (!modalOptions.template &amp;&amp; !modalOptions.templateUrl) {
              throw new Error(&#x27;One of template or templateUrl options is required.&#x27;);
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));

            // Wait for the resolution of the existing promise chain.
            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
            // Then add to $modalStack and resolve opened.
            // Finally clean up the chain variable if no subsequent modal has overwritten it.
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain])
              .then(function() { return templateAndResolvePromise; }, function() { return templateAndResolvePromise; })
              .then(function resolveSuccess(tplAndVars) {

                var modalScope = (modalOptions.scope || $rootScope).$new();
                modalScope.$close = modalInstance.close;
                modalScope.$dismiss = modalInstance.dismiss;

                modalScope.$on(&#x27;$destroy&#x27;, function() {
                  if (!modalScope.$$uibDestructionScheduled) {
                    modalScope.$dismiss(&#x27;$uibUnscheduledDestruction&#x27;);
                  }
                });

                var ctrlInstance, ctrlLocals = {};
                var resolveIter = 1;

                //controllers
                if (modalOptions.controller) {
                  ctrlLocals.$scope = modalScope;
                  ctrlLocals.$modalInstance = modalInstance;
                  angular.forEach(modalOptions.resolve, function(value, key) {
                    ctrlLocals[key] = tplAndVars[resolveIter++];
                  });

                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                  if (modalOptions.controllerAs) {
                    if (modalOptions.bindToController) {
                      angular.extend(ctrlInstance, modalScope);
                    }

                    modalScope[modalOptions.controllerAs] = ctrlInstance;
                  }
                }

                $modalStack.open(modalInstance, {
                  scope: modalScope,
                  deferred: modalResultDeferred,
                  renderDeferred: modalRenderDeferred,
                  content: tplAndVars[0],
                  animation: modalOptions.animation,
                  backdrop: modalOptions.backdrop,
                  keyboard: modalOptions.keyboard,
                  backdropClass: modalOptions.backdropClass,
                  windowClass: modalOptions.windowClass,
                  windowTemplateUrl: modalOptions.windowTemplateUrl,
                  size: modalOptions.size,
                  openedClass: modalOptions.openedClass
                });
                modalOpenedDeferred.resolve(true);

            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            })
            .finally(function() {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });

            return modalInstance;
          };

          return $modal;
        }]
    };

    return $modalProvider;
  });

angular.module(&#x27;ui.bootstrap.pagination&#x27;, [])
.controller(&#x27;PaginationController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;$parse&#x27;, function($scope, $attrs, $parse) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function() {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }

    $scope.$watch(&#x27;totalItems&#x27;, function() {
      $scope.totalPages = self.calculateTotalPages();
    });

    $scope.$watch(&#x27;totalPages&#x27;, function(value) {
      setNumPages($scope.$parent, value); // Readonly variable

      if ( $scope.page &gt; value ) {
        $scope.selectPage(value);
      } else {
        ngModelCtrl.$render();
      }
    });
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage &lt; 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function() {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function(page, evt) {
    if (evt) {
      evt.preventDefault();
    }

    var clickAllowed = !$scope.ngDisabled || !evt;
    if (clickAllowed &amp;&amp; $scope.page !== page &amp;&amp; page &gt; 0 &amp;&amp; page &lt;= $scope.totalPages) {
      if (evt &amp;&amp; evt.target) {
        evt.target.blur();
      }
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function(key) {
    return $scope[key + &#x27;Text&#x27;] || self.config[key + &#x27;Text&#x27;];
  };

  $scope.noPrevious = function() {
    return $scope.page === 1;
  };

  $scope.noNext = function() {
    return $scope.page === $scope.totalPages;
  };
}])

.constant(&#x27;paginationConfig&#x27;, {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: &#x27;First&#x27;,
  previousText: &#x27;Previous&#x27;,
  nextText: &#x27;Next&#x27;,
  lastText: &#x27;Last&#x27;,
  rotate: true
})

.directive(&#x27;pagination&#x27;, [&#x27;$parse&#x27;, &#x27;paginationConfig&#x27;, function($parse, paginationConfig) {
  return {
    restrict: &#x27;EA&#x27;,
    scope: {
      totalItems: &#x27;=&#x27;,
      firstText: &#x27;@&#x27;,
      previousText: &#x27;@&#x27;,
      nextText: &#x27;@&#x27;,
      lastText: &#x27;@&#x27;,
      ngDisabled:&#x27;=&#x27;
    },
    require: [&#x27;pagination&#x27;, &#x27;?ngModel&#x27;],
    controller: &#x27;PaginationController&#x27;,
    controllerAs: &#x27;pagination&#x27;,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/pagination/pagination.html&#x27;;
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) &amp;&amp; maxSize &lt; totalPages;

        // recompute if maxSize
        if (isMaxSized) {
          if (rotate) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage &gt; totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number &lt;= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if (isMaxSized &amp;&amp; ! rotate) {
          if (startPage &gt; 1) {
            var previousPageSet = makePage(startPage - 1, &#x27;...&#x27;, false);
            pages.unshift(previousPageSet);
          }

          if (endPage &lt; totalPages) {
            var nextPageSet = makePage(endPage + 1, &#x27;...&#x27;, false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function() {
        originalRender();
        if (scope.page &gt; 0 &amp;&amp; scope.page &lt;= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}])

.constant(&#x27;pagerConfig&#x27;, {
  itemsPerPage: 10,
  previousText: &#x27;« Previous&#x27;,
  nextText: &#x27;Next »&#x27;,
  align: true
})

.directive(&#x27;pager&#x27;, [&#x27;pagerConfig&#x27;, function(pagerConfig) {
  return {
    restrict: &#x27;EA&#x27;,
    scope: {
      totalItems: &#x27;=&#x27;,
      previousText: &#x27;@&#x27;,
      nextText: &#x27;@&#x27;,
      ngDisabled: &#x27;=&#x27;
    },
    require: [&#x27;pager&#x27;, &#x27;?ngModel&#x27;],
    controller: &#x27;PaginationController&#x27;,
    controllerAs: &#x27;pagination&#x27;,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/pagination/pager.html&#x27;;
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module(&#x27;ui.bootstrap.tooltip&#x27;, [&#x27;ui.bootstrap.position&#x27;, &#x27;ui.bootstrap.bindHtml&#x27;])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider(&#x27;$tooltip&#x27;, function() {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: &#x27;top&#x27;,
    animation: true,
    popupDelay: 0,
    useContentExp: false
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    &#x27;mouseenter&#x27;: &#x27;mouseleave&#x27;,
    &#x27;click&#x27;: &#x27;click&#x27;,
    &#x27;focus&#x27;: &#x27;blur&#x27;,
    &#x27;none&#x27;: &#x27;&#x27;
  };

  // The options specified to the provider globally.
  var globalOptions = {};

  /**
   * &#x60;options({})&#x60; allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( &#x27;App&#x27;, [&#x27;ui.bootstrap.tooltip&#x27;], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: &#x27;left&#x27; } );
   *   });
   */
	this.options = function(value) {
		angular.extend(globalOptions, value);
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( &#x27;openTrigger&#x27;: &#x27;closeTrigger&#x27; );
   */
  this.setTriggers = function setTriggers(triggers) {
    angular.extend(triggerMap, triggers);
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name) {
    var regexp = /[A-Z]/g;
    var separator = &#x27;-&#x27;;
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : &#x27;&#x27;) + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = [&#x27;$window&#x27;, &#x27;$compile&#x27;, &#x27;$timeout&#x27;, &#x27;$document&#x27;, &#x27;$position&#x27;, &#x27;$interpolate&#x27;, &#x27;$rootScope&#x27;, &#x27;$parse&#x27;, function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse) {
    return function $tooltip(type, prefix, defaultTriggerShow, options) {
      options = angular.extend({}, defaultOptions, globalOptions, options);

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the &#x60;trigger&#x60;
       * option passed to the &#x60;$tooltipProvider.options&#x60; method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the &#x60;trigger&#x60; option
       * was passed to the &#x60;$tooltipProvider.options&#x60; method, it will use the
       * mapped trigger from &#x60;triggerMap&#x60; or the passed trigger if the map is
       * undefined; otherwise, it uses the &#x60;triggerMap&#x60; value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers(trigger) {
        var show = (trigger || options.trigger || defaultTriggerShow).split(&#x27; &#x27;);
        var hide = show.map(function(trigger) {
          return triggerMap[trigger] || trigger;
        });
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case(type);

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template =
        &#x27;&lt;div &#x27;+ directiveName +&#x27;-popup &#x27;+
          &#x27;title=&quot;&#x27;+startSym+&#x27;title&#x27;+endSym+&#x27;&quot; &#x27;+
          (options.useContentExp ?
            &#x27;content-exp=&quot;contentExp()&quot; &#x27; :
            &#x27;content=&quot;&#x27;+startSym+&#x27;content&#x27;+endSym+&#x27;&quot; &#x27;) +
          &#x27;placement=&quot;&#x27;+startSym+&#x27;placement&#x27;+endSym+&#x27;&quot; &#x27;+
          &#x27;popup-class=&quot;&#x27;+startSym+&#x27;popupClass&#x27;+endSym+&#x27;&quot; &#x27;+
          &#x27;animation=&quot;animation&quot; &#x27;+
          &#x27;is-open=&quot;isOpen&quot;&#x27;+
          &#x27;origin-scope=&quot;origScope&quot; &#x27;+
          &#x27;&gt;&#x27;+
        &#x27;&lt;/div&gt;&#x27;;

      return {
        restrict: &#x27;EA&#x27;,
        compile: function(tElem, tAttrs) {
          var tooltipLinker = $compile( template );

          return function link(scope, element, attrs, tooltipCtrl) {
            var tooltip;
            var tooltipLinkedScope;
            var transitionTimeout;
            var popupTimeout;
            var positionTimeout;
            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
            var triggers = getTriggers(undefined);
            var hasEnableExp = angular.isDefined(attrs[prefix + &#x27;Enable&#x27;]);
            var ttScope = scope.$new(true);
            var repositionScheduled = false;
            var isOpenExp = angular.isDefined(attrs[prefix + &#x27;IsOpen&#x27;]) ? $parse(attrs[prefix + &#x27;IsOpen&#x27;]) : false;

            var positionTooltip = function() {
              if (!tooltip) { return; }

              if (!positionTimeout) {
                positionTimeout = $timeout(function() {
                  // Reset the positioning and box size for correct width and height values.
                  tooltip.css({ top: 0, left: 0, width: &#x27;auto&#x27;, height: &#x27;auto&#x27; });

                  var ttBox = $position.position(tooltip);
                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                  ttCss.top += &#x27;px&#x27;;
                  ttCss.left += &#x27;px&#x27;;

                  ttCss.width = ttBox.width + &#x27;px&#x27;;
                  ttCss.height = ttBox.height + &#x27;px&#x27;;

                  // Now set the calculated positioning and size.
                  tooltip.css(ttCss);

                  positionTimeout = null;

                }, 0, false);
              }
            };

            // Set up the correct scope to allow transclusion later
            ttScope.origScope = scope;

            // By default, the tooltip is not open.
            // TODO add ability to start tooltip opened
            ttScope.isOpen = false;

            function toggleTooltipBind() {
              if (!ttScope.isOpen) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            // Show the tooltip with delay if specified, otherwise show it immediately
            function showTooltipBind() {
              if (hasEnableExp &amp;&amp; !scope.$eval(attrs[prefix + &#x27;Enable&#x27;])) {
                return;
              }

              prepareTooltip();

              if (ttScope.popupDelay) {
                // Do nothing if the tooltip was already scheduled to pop-up.
                // This happens if show is triggered multiple times before any hide is triggered.
                if (!popupTimeout) {
                  popupTimeout = $timeout(show, ttScope.popupDelay, false);
                }
              } else {
                show();
              }
            }

            function hideTooltipBind () {
              hide();
              if (!$rootScope.$$phase) {
                $rootScope.$digest();
              }
            }

            // Show the tooltip popup element.
            function show() {
              popupTimeout = null;

              // If there is a pending remove transition, we must cancel it, lest the
              // tooltip be mysteriously removed.
              if (transitionTimeout) {
                $timeout.cancel(transitionTimeout);
                transitionTimeout = null;
              }

              // Don&#x27;t show empty tooltips.
              if (!(options.useContentExp ? ttScope.contentExp() : ttScope.content)) {
                return angular.noop;
              }

              createTooltip();

              // And show the tooltip.
              ttScope.isOpen = true;
              if (isOpenExp) {
                isOpenExp.assign(ttScope.origScope, ttScope.isOpen);
              }

              if (!$rootScope.$$phase) {
                ttScope.$apply(); // digest required as $apply is not called
              }

              tooltip.css({ display: &#x27;block&#x27; });

              positionTooltip();
            }

            // Hide the tooltip popup element.
            function hide() {
              // First things first: we don&#x27;t show it anymore.
              ttScope.isOpen = false;
              if (isOpenExp) {
                isOpenExp.assign(ttScope.origScope, ttScope.isOpen);
              }

              //if tooltip is going to be shown after delay, we must cancel this
              $timeout.cancel(popupTimeout);
              popupTimeout = null;

              $timeout.cancel(positionTimeout);
              positionTimeout = null;

              // And now we remove it from the DOM. However, if we have animation, we
              // need to wait for it to expire beforehand.
              // FIXME: this is a placeholder for a port of the transitions library.
              if (ttScope.animation) {
                if (!transitionTimeout) {
                  transitionTimeout = $timeout(removeTooltip, 500);
                }
              } else {
                removeTooltip();
              }
            }

            function createTooltip() {
              // There can only be one tooltip element per directive shown at once.
              if (tooltip) {
                removeTooltip();
              }
              tooltipLinkedScope = ttScope.$new();
              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                if (appendToBody) {
                  $document.find(&#x27;body&#x27;).append(tooltip);
                } else {
                  element.after(tooltip);
                }
              });

              if (options.useContentExp) {
                tooltipLinkedScope.$watch(&#x27;contentExp()&#x27;, function(val) {
                  if (!val &amp;&amp; ttScope.isOpen) {
                    hide();
                  }
                });

                tooltipLinkedScope.$watch(function() {
                  if (!repositionScheduled) {
                    repositionScheduled = true;
                    tooltipLinkedScope.$$postDigest(function() {
                      repositionScheduled = false;
                      if (ttScope.isOpen) {
                        positionTooltip();
                      }
                    });
                  }
                });

              }
            }

            function removeTooltip() {
              transitionTimeout = null;
              if (tooltip) {
                tooltip.remove();
                tooltip = null;
              }
              if (tooltipLinkedScope) {
                tooltipLinkedScope.$destroy();
                tooltipLinkedScope = null;
              }
            }

            function prepareTooltip() {
              prepPopupClass();
              prepPlacement();
              prepPopupDelay();
            }

            ttScope.contentExp = function() {
              return scope.$eval(attrs[type]);
            };

            /**
             * Observe the relevant attributes.
             */
            if (!options.useContentExp) {
              attrs.$observe(type, function(val) {
                ttScope.content = val;

                if (!val &amp;&amp; ttScope.isOpen) {
                  hide();
                } else {
                  positionTooltip();
                }
              });
            }

            attrs.$observe(&#x27;disabled&#x27;, function(val) {
              if (popupTimeout &amp;&amp; val) {
                $timeout.cancel(popupTimeout);
                popupTimeout = null;
              }

              if (val &amp;&amp; ttScope.isOpen) {
                hide();
              }
            });

            attrs.$observe(prefix + &#x27;Title&#x27;, function(val) {
              ttScope.title = val;
              positionTooltip();
            });

            attrs.$observe(prefix + &#x27;Placement&#x27;, function() {
              if (ttScope.isOpen) {
                prepPlacement();
                positionTooltip();
              }
            });

            if (isOpenExp) {
              scope.$watch(isOpenExp, function(val) {
                if (val !== ttScope.isOpen) {
                  toggleTooltipBind();
                }
              });
            }

            function prepPopupClass() {
              ttScope.popupClass = attrs[prefix + &#x27;Class&#x27;];
            }

            function prepPlacement() {
              var val = attrs[prefix + &#x27;Placement&#x27;];
              ttScope.placement = angular.isDefined(val) ? val : options.placement;
            }

            function prepPopupDelay() {
              var val = attrs[prefix + &#x27;PopupDelay&#x27;];
              var delay = parseInt(val, 10);
              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
            }

            var unregisterTriggers = function() {
              triggers.show.forEach(function(trigger) {
                element.unbind(trigger, showTooltipBind);
              });
              triggers.hide.forEach(function(trigger) {
                element.unbind(trigger, hideTooltipBind);
              });
            };

            function prepTriggers() {
              var val = attrs[prefix + &#x27;Trigger&#x27;];
              unregisterTriggers();

              triggers = getTriggers(val);

              if (triggers.show !== &#x27;none&#x27;) {
                triggers.show.forEach(function(trigger, idx) {
                  // Using raw addEventListener due to jqLite/jQuery bug - #4060
                  if (trigger === triggers.hide[idx]) {
                    element[0].addEventListener(trigger, toggleTooltipBind);
                  } else if (trigger) {
                    element[0].addEventListener(trigger, showTooltipBind);
                    element[0].addEventListener(triggers.hide[idx], hideTooltipBind);
                  }
                });
              }
            }
            prepTriggers();

            var animation = scope.$eval(attrs[prefix + &#x27;Animation&#x27;]);
            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

            var appendToBodyVal = scope.$eval(attrs[prefix + &#x27;AppendToBody&#x27;]);
            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

            // if a tooltip is attached to &lt;body&gt; we need to remove it on
            // location change as its parent scope will probably not be destroyed
            // by the change.
            if (appendToBody) {
              scope.$on(&#x27;$locationChangeSuccess&#x27;, function closeTooltipOnLocationChangeSuccess() {
                if (ttScope.isOpen) {
                  hide();
                }
              });
            }

            // Make sure tooltip is destroyed and removed.
            scope.$on(&#x27;$destroy&#x27;, function onDestroyTooltip() {
              $timeout.cancel(transitionTimeout);
              $timeout.cancel(popupTimeout);
              $timeout.cancel(positionTimeout);
              unregisterTriggers();
              removeTooltip();
              ttScope = null;
            });
          };
        }
      };
    };
  }];
})

// This is mostly ngInclude code but with a custom scope
.directive(&#x27;tooltipTemplateTransclude&#x27;, [
         &#x27;$animate&#x27;, &#x27;$sce&#x27;, &#x27;$compile&#x27;, &#x27;$templateRequest&#x27;,
function ($animate ,  $sce ,  $compile ,  $templateRequest) {
  return {
    link: function(scope, elem, attrs) {
      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }
        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }
        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit(&#x27;$includeContentLoaded&#x27;, src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit(&#x27;$includeContentError&#x27;, src);
            }
          });
          scope.$emit(&#x27;$includeContentRequested&#x27;, src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on(&#x27;$destroy&#x27;, cleanupLastIncludeContent);
    }
  };
}])

/**
 * Note that it&#x27;s intentional that these classes are *not* applied through $animate.
 * They must not be animated as they&#x27;re expected to be present on the tooltip on
 * initialization.
 */
.directive(&#x27;tooltipClasses&#x27;, function() {
  return {
    restrict: &#x27;A&#x27;,
    link: function(scope, element, attrs) {
      if (scope.placement) {
        element.addClass(scope.placement);
      }
      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }
      if (scope.animation()) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
})

.directive(&#x27;tooltipPopup&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { content: &#x27;@&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/tooltip/tooltip-popup.html&#x27;
  };
})

.directive(&#x27;tooltip&#x27;, [ &#x27;$tooltip&#x27;, function($tooltip) {
  return $tooltip(&#x27;tooltip&#x27;, &#x27;tooltip&#x27;, &#x27;mouseenter&#x27;);
}])

.directive(&#x27;tooltipTemplatePopup&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { contentExp: &#x27;&amp;&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27;,
      originScope: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/tooltip/tooltip-template-popup.html&#x27;
  };
})

.directive(&#x27;tooltipTemplate&#x27;, [&#x27;$tooltip&#x27;, function($tooltip) {
  return $tooltip(&#x27;tooltipTemplate&#x27;, &#x27;tooltip&#x27;, &#x27;mouseenter&#x27;, {
    useContentExp: true
  });
}])

.directive(&#x27;tooltipHtmlPopup&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { contentExp: &#x27;&amp;&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/tooltip/tooltip-html-popup.html&#x27;
  };
})

.directive(&#x27;tooltipHtml&#x27;, [&#x27;$tooltip&#x27;, function($tooltip) {
  return $tooltip(&#x27;tooltipHtml&#x27;, &#x27;tooltip&#x27;, &#x27;mouseenter&#x27;, {
    useContentExp: true
  });
}])

/*
Deprecated
*/
.directive(&#x27;tooltipHtmlUnsafePopup&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { content: &#x27;@&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/tooltip/tooltip-html-unsafe-popup.html&#x27;
  };
})

.value(&#x27;tooltipHtmlUnsafeSuppressDeprecated&#x27;, false)
.directive(&#x27;tooltipHtmlUnsafe&#x27;, [
          &#x27;$tooltip&#x27;, &#x27;tooltipHtmlUnsafeSuppressDeprecated&#x27;, &#x27;$log&#x27;,
function($tooltip ,  tooltipHtmlUnsafeSuppressDeprecated ,  $log) {
  if (!tooltipHtmlUnsafeSuppressDeprecated) {
    $log.warn(&#x27;tooltip-html-unsafe is now deprecated. Use tooltip-html or tooltip-template instead.&#x27;);
  }
  return $tooltip(&#x27;tooltipHtmlUnsafe&#x27;, &#x27;tooltip&#x27;, &#x27;mouseenter&#x27;);
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, and selector delegatation.
 */
angular.module( &#x27;ui.bootstrap.popover&#x27;, [&#x27;ui.bootstrap.tooltip&#x27;])

.directive(&#x27;popoverTemplatePopup&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { title: &#x27;@&#x27;, contentExp: &#x27;&amp;&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27;,
      originScope: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/popover/popover-template.html&#x27;
  };
})

.directive(&#x27;popoverTemplate&#x27;, [&#x27;$tooltip&#x27;, function($tooltip) {
  return $tooltip(&#x27;popoverTemplate&#x27;, &#x27;popover&#x27;, &#x27;click&#x27;, {
    useContentExp: true
  });
}])

.directive(&#x27;popoverHtmlPopup&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { contentExp: &#x27;&amp;&#x27;, title: &#x27;@&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/popover/popover-html.html&#x27;
  };
})

.directive(&#x27;popoverHtml&#x27;, [&#x27;$tooltip&#x27;, function($tooltip) {
  return $tooltip( &#x27;popoverHtml&#x27;, &#x27;popover&#x27;, &#x27;click&#x27;, {
    useContentExp: true
  });
}])

.directive(&#x27;popoverPopup&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    scope: { title: &#x27;@&#x27;, content: &#x27;@&#x27;, placement: &#x27;@&#x27;, popupClass: &#x27;@&#x27;, animation: &#x27;&amp;&#x27;, isOpen: &#x27;&amp;&#x27; },
    templateUrl: &#x27;template/popover/popover.html&#x27;
  };
})

.directive(&#x27;popover&#x27;, [&#x27;$tooltip&#x27;, function($tooltip) {
  return $tooltip( &#x27;popover&#x27;, &#x27;popover&#x27;, &#x27;click&#x27; );
}]);

angular.module(&#x27;ui.bootstrap.progressbar&#x27;, [])

.constant(&#x27;progressConfig&#x27;, {
  animate: true,
  max: 100
})

.value(&#x27;$progressSuppressWarning&#x27;, false)

.controller(&#x27;ProgressController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;progressConfig&#x27;, function($scope, $attrs, progressConfig) {
  var self = this,
      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;

  this.addBar = function(bar, element) {
    if (!animate) {
      element.css({&#x27;transition&#x27;: &#x27;none&#x27;});
    }

    this.bars.push(bar);

    bar.max = $scope.max;

    bar.$watch(&#x27;value&#x27;, function(value) {
      bar.recalculatePercentage();
    });

    bar.recalculatePercentage = function() {
      bar.percent = +(100 * bar.value / bar.max).toFixed(2);

      var totalPercentage = self.bars.reduce(function(total, bar) {
        return total + bar.percent;
      }, 0);

      if (totalPercentage &gt; 100) {
        bar.percent -= totalPercentage - 100;
      }
    };

    bar.$on(&#x27;$destroy&#x27;, function() {
      element = null;
      self.removeBar(bar);
    });
  };

  this.removeBar = function(bar) {
      this.bars.splice(this.bars.indexOf(bar), 1);
  };

  $scope.$watch(&#x27;max&#x27;, function(max) {
    self.bars.forEach(function(bar) {
      bar.max = $scope.max;
      bar.recalculatePercentage();
    });
  });
}])

.directive(&#x27;uibProgress&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    transclude: true,
    controller: &#x27;ProgressController&#x27;,
    require: &#x27;uibProgress&#x27;,
    scope: {
      max: &#x27;=?&#x27;
    },
    templateUrl: &#x27;template/progressbar/progress.html&#x27;
  };
})

.directive(&#x27;progress&#x27;, [&#x27;$log&#x27;, &#x27;$progressSuppressWarning&#x27;, function($log, $progressSuppressWarning) {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    transclude: true,
    controller: &#x27;ProgressController&#x27;,
    require: &#x27;progress&#x27;,
    scope: {
      max: &#x27;=?&#x27;
    },
    templateUrl: &#x27;template/progressbar/progress.html&#x27;,
    link: function() {
      if ($progressSuppressWarning) {
        $log.warn(&#x27;progress is now deprecated. Use uib-progress instead&#x27;);
      }
    }
  };
}])

.directive(&#x27;uibBar&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    transclude: true,
    require: &#x27;^uibProgress&#x27;,
    scope: {
      value: &#x27;=&#x27;,
      type: &#x27;@&#x27;
    },
    templateUrl: &#x27;template/progressbar/bar.html&#x27;,
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, element);
    }
  };
})

.directive(&#x27;bar&#x27;, [&#x27;$log&#x27;, &#x27;$progressSuppressWarning&#x27;, function($log, $progressSuppressWarning) {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    transclude: true,
    require: &#x27;^progress&#x27;,
    scope: {
      value: &#x27;=&#x27;,
      type: &#x27;@&#x27;
    },
    templateUrl: &#x27;template/progressbar/bar.html&#x27;,
    link: function(scope, element, attrs, progressCtrl) {
      if ($progressSuppressWarning) {
        $log.warn(&#x27;bar is now deprecated. Use uib-bar instead&#x27;);
      }
      progressCtrl.addBar(scope, element);
    }
  };
}])

.directive(&#x27;progressbar&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    replace: true,
    transclude: true,
    controller: &#x27;ProgressController&#x27;,
    scope: {
      value: &#x27;=&#x27;,
      max: &#x27;=?&#x27;,
      type: &#x27;@&#x27;
    },
    templateUrl: &#x27;template/progressbar/progressbar.html&#x27;,
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, angular.element(element.children()[0]));
    }
  };
});

angular.module(&#x27;ui.bootstrap.rating&#x27;, [])

.constant(&#x27;ratingConfig&#x27;, {
  max: 5,
  stateOn: null,
  stateOff: null,
  titles : [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;]
})

.controller(&#x27;RatingController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;ratingConfig&#x27;, function($scope, $attrs, ratingConfig) {
  var ngModelCtrl  = { $setViewValue: angular.noop };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.push(function(value) {
      if (angular.isNumber(value) &amp;&amp; value &lt;&lt; 0 !== value) {
        value = Math.round(value);
      }
      return value;
    });

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;    
    this.titles = angular.isArray(tmpTitles) &amp;&amp; tmpTitles.length &gt; 0 ?
      tmpTitles : ratingConfig.titles;
    
    var ratingStates = angular.isDefined($attrs.ratingStates) ?
      $scope.$parent.$eval($attrs.ratingStates) :
      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i &lt; n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
    }
    return states;
  };
  
  this.getTitle = function(index) {
    if (index &gt;= this.titles.length) {
      return index + 1;
    } else {
      return this.titles[index];
    }
  };
  
  $scope.rate = function(value) {
    if (!$scope.readonly &amp;&amp; value &gt;= 0 &amp;&amp; value &lt;= $scope.range.length) {
      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if (!$scope.readonly) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
  };
}])

.directive(&#x27;rating&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    require: [&#x27;rating&#x27;, &#x27;ngModel&#x27;],
    scope: {
      readonly: &#x27;=?&#x27;,
      onHover: &#x27;&amp;&#x27;,
      onLeave: &#x27;&amp;&#x27;
    },
    controller: &#x27;RatingController&#x27;,
    templateUrl: &#x27;template/rating/rating.html&#x27;,
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init( ngModelCtrl );
    }
  };
});


/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module(&#x27;ui.bootstrap.tabs&#x27;, [])

.controller(&#x27;TabsetController&#x27;, [&#x27;$scope&#x27;, function TabsetCtrl($scope) {
  var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(selectedTab) {
    angular.forEach(tabs, function(tab) {
      if (tab.active &amp;&amp; tab !== selectedTab) {
        tab.active = false;
        tab.onDeselect();
        selectedTab.selectCalled = false;
      }
    });
    selectedTab.active = true;
    // only call select if it has not already been called
    if (!selectedTab.selectCalled) {
      selectedTab.onSelect();
      selectedTab.selectCalled = true;
    }
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    // we can&#x27;t run the select function on the first tab
    // since that would select it twice
    if (tabs.length === 1 &amp;&amp; tab.active !== false) {
      tab.active = true;
    } else if (tab.active) {
      ctrl.select(tab);
    } else {
      tab.active = false;
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected and not destroyed
    if (tab.active &amp;&amp; tabs.length &gt; 1 &amp;&amp; !destroyed) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };

  var destroyed;
  $scope.$on(&#x27;$destroy&#x27;, function() {
    destroyed = true;
  });
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
    &lt;tabset&gt;
      &lt;tab heading=&quot;Tab 1&quot;&gt;&lt;b&gt;First&lt;/b&gt; Content!&lt;/tab&gt;
      &lt;tab heading=&quot;Tab 2&quot;&gt;&lt;i&gt;Second&lt;/i&gt; Content!&lt;/tab&gt;
    &lt;/tabset&gt;
    &lt;hr /&gt;
    &lt;tabset vertical=&quot;true&quot;&gt;
      &lt;tab heading=&quot;Vertical Tab 1&quot;&gt;&lt;b&gt;First&lt;/b&gt; Vertical Content!&lt;/tab&gt;
      &lt;tab heading=&quot;Vertical Tab 2&quot;&gt;&lt;i&gt;Second&lt;/i&gt; Vertical Content!&lt;/tab&gt;
    &lt;/tabset&gt;
    &lt;tabset justified=&quot;true&quot;&gt;
      &lt;tab heading=&quot;Justified Tab 1&quot;&gt;&lt;b&gt;First&lt;/b&gt; Justified Content!&lt;/tab&gt;
      &lt;tab heading=&quot;Justified Tab 2&quot;&gt;&lt;i&gt;Second&lt;/i&gt; Justified Content!&lt;/tab&gt;
    &lt;/tabset&gt;
  &lt;/file&gt;
&lt;/example&gt;
 */
.directive(&#x27;tabset&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    transclude: true,
    replace: true,
    scope: {
      type: &#x27;@&#x27;
    },
    controller: &#x27;TabsetController&#x27;,
    templateUrl: &#x27;template/tabs/tabset.html&#x27;,
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
    &lt;div ng-controller=&quot;TabsDemoCtrl&quot;&gt;
      &lt;button class=&quot;btn btn-small&quot; ng-click=&quot;items[0].active = true&quot;&gt;
        Select item 1, using active binding
      &lt;/button&gt;
      &lt;button class=&quot;btn btn-small&quot; ng-click=&quot;items[1].disabled = !items[1].disabled&quot;&gt;
        Enable/disable item 2, using disabled binding
      &lt;/button&gt;
      &lt;br /&gt;
      &lt;tabset&gt;
        &lt;tab heading=&quot;Tab 1&quot;&gt;First Tab&lt;/tab&gt;
        &lt;tab select=&quot;alertMe()&quot;&gt;
          &lt;tab-heading&gt;&lt;i class=&quot;icon-bell&quot;&gt;&lt;/i&gt; Alert me!&lt;/tab-heading&gt;
          Second Tab, with alert callback and html heading!
        &lt;/tab&gt;
        &lt;tab ng-repeat=&quot;item in items&quot;
          heading=&quot;{{item.title}}&quot;
          disabled=&quot;item.disabled&quot;
          active=&quot;item.active&quot;&gt;
          {{item.content}}
        &lt;/tab&gt;
      &lt;/tabset&gt;
    &lt;/div&gt;
  &lt;/file&gt;
  &lt;file name=&quot;script.js&quot;&gt;
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:&quot;Dynamic Title 1&quot;, content:&quot;Dynamic Item 0&quot; },
        { title:&quot;Dynamic Title 2&quot;, content:&quot;Dynamic Item 1&quot;, disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert(&quot;You&#x27;ve selected the alert tab!&quot;);
        });
      };
    };
  &lt;/file&gt;
&lt;/example&gt;
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
&lt;example module=&quot;ui.bootstrap&quot;&gt;
  &lt;file name=&quot;index.html&quot;&gt;
    &lt;tabset&gt;
      &lt;tab&gt;
        &lt;tab-heading&gt;&lt;b&gt;HTML&lt;/b&gt; in my titles?!&lt;/tab-heading&gt;
        And some content, too!
      &lt;/tab&gt;
      &lt;tab&gt;
        &lt;tab-heading&gt;&lt;i class=&quot;icon-heart&quot;&gt;&lt;/i&gt; Icon heading?!?&lt;/tab-heading&gt;
        That&#x27;s right.
      &lt;/tab&gt;
    &lt;/tabset&gt;
  &lt;/file&gt;
&lt;/example&gt;
 */
.directive(&#x27;tab&#x27;, [&#x27;$parse&#x27;, &#x27;$log&#x27;, function($parse, $log) {
  return {
    require: &#x27;^tabset&#x27;,
    restrict: &#x27;EA&#x27;,
    replace: true,
    templateUrl: &#x27;template/tabs/tab.html&#x27;,
    transclude: true,
    scope: {
      active: &#x27;=?&#x27;,
      heading: &#x27;@&#x27;,
      onSelect: &#x27;&amp;select&#x27;, //This callback is called in contentHeadingTransclude
                          //once it inserts the tab&#x27;s content into the dom
      onDeselect: &#x27;&amp;deselect&#x27;
    },
    controller: function() {
      //Empty controller so other directives can require being &#x27;under&#x27; a tab
    },
    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
      scope.$watch(&#x27;active&#x27;, function(active) {
        if (active) {
          tabsetCtrl.select(scope);
        }
      });

      scope.disabled = false;
      if (attrs.disable) {
        scope.$parent.$watch($parse(attrs.disable), function(value) {
          scope.disabled = !! value;
        });
      }

      // Deprecation support of &quot;disabled&quot; parameter
      // fix(tab): IE9 disabled attr renders grey text on enabled tab #2677
      // This code is duplicated from the lines above to make it easy to remove once
      // the feature has been completely deprecated
      if (attrs.disabled) {
        $log.warn(&#x27;Use of &quot;disabled&quot; attribute has been deprecated, please use &quot;disable&quot;&#x27;);
        scope.$parent.$watch($parse(attrs.disabled), function(value) {
          scope.disabled = !! value;
        });
      }

      scope.select = function() {
        if (!scope.disabled) {
          scope.active = true;
        }
      };

      tabsetCtrl.addTab(scope);
      scope.$on(&#x27;$destroy&#x27;, function() {
        tabsetCtrl.removeTab(scope);
      });

      //We need to transclude later, once the content container is ready.
      //when this link happens, we&#x27;re inside a tab heading.
      scope.$transcludeFn = transclude;
    }
  };
}])

.directive(&#x27;tabHeadingTransclude&#x27;, function() {
  return {
    restrict: &#x27;A&#x27;,
    require: &#x27;^tab&#x27;,
    link: function(scope, elm, attrs, tabCtrl) {
      scope.$watch(&#x27;headingElement&#x27;, function updateHeadingElement(heading) {
        if (heading) {
          elm.html(&#x27;&#x27;);
          elm.append(heading);
        }
      });
    }
  };
})

.directive(&#x27;tabContentTransclude&#x27;, function() {
  return {
    restrict: &#x27;A&#x27;,
    require: &#x27;^tabset&#x27;,
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude &#x27;em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };

  function isTabHeading(node) {
    return node.tagName &amp;&amp; (
      node.hasAttribute(&#x27;tab-heading&#x27;) ||
      node.hasAttribute(&#x27;data-tab-heading&#x27;) ||
      node.hasAttribute(&#x27;x-tab-heading&#x27;) ||
      node.tagName.toLowerCase() === &#x27;tab-heading&#x27; ||
      node.tagName.toLowerCase() === &#x27;data-tab-heading&#x27; ||
      node.tagName.toLowerCase() === &#x27;x-tab-heading&#x27;
    );
  }
});

angular.module(&#x27;ui.bootstrap.timepicker&#x27;, [])

.constant(&#x27;timepickerConfig&#x27;, {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: null,
  readonlyInput: false,
  mousewheel: true,
  arrowkeys: true,
  showSpinners: true
})

.controller(&#x27;TimepickerController&#x27;, [&#x27;$scope&#x27;, &#x27;$attrs&#x27;, &#x27;$parse&#x27;, &#x27;$log&#x27;, &#x27;$locale&#x27;, &#x27;timepickerConfig&#x27;, function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;

  this.init = function(ngModelCtrl_, inputs) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.unshift(function(modelValue) {
      return modelValue ? new Date(modelValue) : null;
    });

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1);

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
    if (mousewheel) {
      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
    }

    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
    if (arrowkeys) {
      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents(hoursInputEl, minutesInputEl);
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = parseInt(value, 10);
    });
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = parseInt(value, 10);
    });
  }

  var min;
  $scope.$parent.$watch($parse($attrs.min), function(value) {
    var dt = new Date(value);
    min = isNaN(dt) ? undefined : dt;
  });

  var max;
  $scope.$parent.$watch($parse($attrs.max), function(value) {
    var dt = new Date(value);
    max = isNaN(dt) ? undefined : dt;
  });

  $scope.noIncrementHours = function() {
    var incrementedSelected = addMinutes(selected, hourStep * 60);
    return incrementedSelected &gt; max ||
      (incrementedSelected &lt; selected &amp;&amp; incrementedSelected &lt; min);
  };

  $scope.noDecrementHours = function() {
    var decrementedSelected = addMinutes(selected, -hourStep * 60);
    return decrementedSelected &lt; min ||
      (decrementedSelected &gt; selected &amp;&amp; decrementedSelected &gt; max);
  };

  $scope.noIncrementMinutes = function() {
    var incrementedSelected = addMinutes(selected, minuteStep);
    return incrementedSelected &gt; max ||
      (incrementedSelected &lt; selected &amp;&amp; incrementedSelected &lt; min);
  };

  $scope.noDecrementMinutes = function() {
    var decrementedSelected = addMinutes(selected, -minuteStep);
    return decrementedSelected &lt; min ||
      (decrementedSelected &gt; selected &amp;&amp; decrementedSelected &gt; max);
  };

  $scope.noToggleMeridian = function() {
    if (selected.getHours() &lt; 13) {
      return addMinutes(selected, 12 * 60) &gt; max;
    } else {
      return addMinutes(selected, -12 * 60) &lt; min;
    }
  };

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if (ngModelCtrl.$error.time) {
        // Evaluate from template
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined(hours) &amp;&amp; angular.isDefined(minutes)) {
          selected.setHours(hours);
          refresh();
        }
      } else {
        updateTemplate();
      }
    });
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate() {
    var hours = parseInt($scope.hours, 10);
    var valid = $scope.showMeridian ? (hours &gt; 0 &amp;&amp; hours &lt; 13) : (hours &gt;= 0 &amp;&amp; hours &lt; 24);
    if (!valid) {
      return undefined;
    }

    if ($scope.showMeridian) {
      if (hours === 12) {
        hours = 0;
      }
      if ($scope.meridian === meridians[1]) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = parseInt($scope.minutes, 10);
    return (minutes &gt;= 0 &amp;&amp; minutes &lt; 60) ? minutes : undefined;
  }

  function pad(value) {
    return (angular.isDefined(value) &amp;&amp; value.toString().length &lt; 2) ? &#x27;0&#x27; + value : value.toString();
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
      return (e.detail || delta &gt; 0);
    };

    hoursInputEl.bind(&#x27;mousewheel wheel&#x27;, function(e) {
      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
      e.preventDefault();
    });

    minutesInputEl.bind(&#x27;mousewheel wheel&#x27;, function(e) {
      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
      e.preventDefault();
    });

  };

  // Respond on up/down arrowkeys
  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
    hoursInputEl.bind(&#x27;keydown&#x27;, function(e) {
      if (e.which === 38) { // up
        e.preventDefault();
        $scope.incrementHours();
        $scope.$apply();
      } else if (e.which === 40) { // down
        e.preventDefault();
        $scope.decrementHours();
        $scope.$apply();
      }
    });

    minutesInputEl.bind(&#x27;keydown&#x27;, function(e) {
      if (e.which === 38) { // up
        e.preventDefault();
        $scope.incrementMinutes();
        $scope.$apply();
      } else if (e.which === 40) { // down
        e.preventDefault();
        $scope.decrementMinutes();
        $scope.$apply();
      }
    });
  };

  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
    if ($scope.readonlyInput) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes) {
      ngModelCtrl.$setViewValue(null);
      ngModelCtrl.$setValidity(&#x27;time&#x27;, false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
      }
      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate(),
        minutes = getMinutesFromTemplate();

      if (angular.isDefined(hours) &amp;&amp; angular.isDefined(minutes)) {
        selected.setHours(hours);
        if (selected &lt; min || selected &gt; max) {
          invalidate(true);
        } else {
          refresh(&#x27;h&#x27;);
        }
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.bind(&#x27;blur&#x27;, function(e) {
      if (!$scope.invalidHours &amp;&amp; $scope.hours &lt; 10) {
        $scope.$apply(function() {
          $scope.hours = pad($scope.hours);
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

      if (angular.isDefined(minutes) &amp;&amp; angular.isDefined(hours)) {
        selected.setMinutes(minutes);
        if (selected &lt; min || selected &gt; max) {
          invalidate(undefined, true);
        } else {
          refresh(&#x27;m&#x27;);
        }
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.bind(&#x27;blur&#x27;, function(e) {
      if (!$scope.invalidMinutes &amp;&amp; $scope.minutes &lt; 10) {
        $scope.$apply(function() {
          $scope.minutes = pad($scope.minutes);
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$viewValue;

    if (isNaN(date)) {
      ngModelCtrl.$setValidity(&#x27;time&#x27;, false);
      $log.error(&#x27;Timepicker directive: &quot;ng-model&quot; value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.&#x27;);
    } else {
      if (date) {
        selected = date;
      }

      if (selected &lt; min || selected &gt; max) {
        ngModelCtrl.$setValidity(&#x27;time&#x27;, false);
        $scope.invalidHours = true;
        $scope.invalidMinutes = true;
      } else {
        makeValid();
      }
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh(keyboardChange) {
    makeValid();
    ngModelCtrl.$setViewValue(new Date(selected));
    updateTemplate(keyboardChange);
  }

  function makeValid() {
    ngModelCtrl.$setValidity(&#x27;time&#x27;, true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
  }

  function updateTemplate(keyboardChange) {
    var hours = selected.getHours(), minutes = selected.getMinutes();

    if ($scope.showMeridian) {
      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system
    }

    $scope.hours = keyboardChange === &#x27;h&#x27; ? hours : pad(hours);
    if (keyboardChange !== &#x27;m&#x27;) {
      $scope.minutes = pad(minutes);
    }
    $scope.meridian = selected.getHours() &lt; 12 ? meridians[0] : meridians[1];
  }

  function addMinutes(date, minutes) {
    var dt = new Date(date.getTime() + minutes * 60000);
    var newDate = new Date(date);
    newDate.setHours(dt.getHours(), dt.getMinutes());
    return newDate;
  }

  function addMinutesToSelected(minutes) {
    selected = addMinutes(selected, minutes);
    refresh();
  }

  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

  $scope.incrementHours = function() {
    if (!$scope.noIncrementHours()) {
      addMinutesToSelected(hourStep * 60);
    }
  };

  $scope.decrementHours = function() {
    if (!$scope.noDecrementHours()) {
      addMinutesToSelected(-hourStep * 60);
    }
  };

  $scope.incrementMinutes = function() {
    if (!$scope.noIncrementMinutes()) {
      addMinutesToSelected(minuteStep);
    }
  };

  $scope.decrementMinutes = function() {
    if (!$scope.noDecrementMinutes()) {
      addMinutesToSelected(-minuteStep);
    }
  };

  $scope.toggleMeridian = function() {
    if (!$scope.noToggleMeridian()) {
      addMinutesToSelected(12 * 60 * (selected.getHours() &lt; 12 ? 1 : -1));
    }
  };
}])

.directive(&#x27;timepicker&#x27;, function() {
  return {
    restrict: &#x27;EA&#x27;,
    require: [&#x27;timepicker&#x27;, &#x27;?^ngModel&#x27;],
    controller:&#x27;TimepickerController&#x27;,
    controllerAs: &#x27;timepicker&#x27;,
    replace: true,
    scope: {},
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || &#x27;template/timepicker/timepicker.html&#x27;;
    },
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find(&#x27;input&#x27;));
      }
    }
  };
});

angular.module(&#x27;ui.bootstrap.transition&#x27;, [])

.value(&#x27;$transitionSuppressDeprecated&#x27;, false)
/**
 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
 * @param  {DOMElement} element  The DOMElement that will be animated.
 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
 *   - As a string, it represents the css class to be added to the element.
 *   - As an object, it represents a hash of style attributes to be applied to the element.
 *   - As a function, it represents a function to be called that will cause the transition to occur.
 * @return {Promise}  A promise that is resolved when the transition finishes.
 */
.factory(&#x27;$transition&#x27;, [
        &#x27;$q&#x27;, &#x27;$timeout&#x27;, &#x27;$rootScope&#x27;, &#x27;$log&#x27;, &#x27;$transitionSuppressDeprecated&#x27;,
function($q ,  $timeout ,  $rootScope ,  $log ,  $transitionSuppressDeprecated) {

  if (!$transitionSuppressDeprecated) {
    $log.warn(&#x27;$transition is now deprecated. Use $animate from ngAnimate instead.&#x27;);
  }

  var $transition = function(element, trigger, options) {
    options = options || {};
    var deferred = $q.defer();
    var endEventName = $transition[options.animation ? &#x27;animationEndEventName&#x27; : &#x27;transitionEndEventName&#x27;];

    var transitionEndHandler = function(event) {
      $rootScope.$apply(function() {
        element.unbind(endEventName, transitionEndHandler);
        deferred.resolve(element);
      });
    };

    if (endEventName) {
      element.bind(endEventName, transitionEndHandler);
    }

    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
    $timeout(function() {
      if ( angular.isString(trigger) ) {
        element.addClass(trigger);
      } else if ( angular.isFunction(trigger) ) {
        trigger(element);
      } else if ( angular.isObject(trigger) ) {
        element.css(trigger);
      }
      //If browser does not support transitions, instantly resolve
      if ( !endEventName ) {
        deferred.resolve(element);
      }
    });

    // Add our custom cancel function to the promise that is returned
    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
    // i.e. it will therefore never raise a transitionEnd event for that transition
    deferred.promise.cancel = function() {
      if ( endEventName ) {
        element.unbind(endEventName, transitionEndHandler);
      }
      deferred.reject(&#x27;Transition cancelled&#x27;);
    };

    return deferred.promise;
  };

  // Work out the name of the transitionEnd event
  var transElement = document.createElement(&#x27;trans&#x27;);
  var transitionEndEventNames = {
    &#x27;WebkitTransition&#x27;: &#x27;webkitTransitionEnd&#x27;,
    &#x27;MozTransition&#x27;: &#x27;transitionend&#x27;,
    &#x27;OTransition&#x27;: &#x27;oTransitionEnd&#x27;,
    &#x27;transition&#x27;: &#x27;transitionend&#x27;
  };
  var animationEndEventNames = {
    &#x27;WebkitTransition&#x27;: &#x27;webkitAnimationEnd&#x27;,
    &#x27;MozTransition&#x27;: &#x27;animationend&#x27;,
    &#x27;OTransition&#x27;: &#x27;oAnimationEnd&#x27;,
    &#x27;transition&#x27;: &#x27;animationend&#x27;
  };
  function findEndEventName(endEventNames) {
    for (var name in endEventNames){
      if (transElement.style[name] !== undefined) {
        return endEventNames[name];
      }
    }
  }
  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
  return $transition;
}]);

angular.module(&#x27;ui.bootstrap.typeahead&#x27;, [&#x27;ui.bootstrap.position&#x27;])

/**
 * A helper service that can parse typeahead&#x27;s syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory(&#x27;typeaheadParser&#x27;, [&#x27;$parse&#x27;, function($parse) {

  //                      00000111000000000000022200000000000000003333333333333330000000000044000
  var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;

  return {
    parse: function(input) {
      var match = input.match(TYPEAHEAD_REGEXP);
      if (!match) {
        throw new Error(
          &#x27;Expected typeahead specification in form of &quot;_modelValue_ (as _label_)? for _item_ in _collection_&quot;&#x27; +
            &#x27; but got &quot;&#x27; + input + &#x27;&quot;.&#x27;);
      }

      return {
        itemName:match[3],
        source:$parse(match[4]),
        viewMapper:$parse(match[2] || match[1]),
        modelMapper:$parse(match[1])
      };
    }
  };
}])

  .directive(&#x27;typeahead&#x27;, [&#x27;$compile&#x27;, &#x27;$parse&#x27;, &#x27;$q&#x27;, &#x27;$timeout&#x27;, &#x27;$document&#x27;, &#x27;$window&#x27;, &#x27;$rootScope&#x27;, &#x27;$position&#x27;, &#x27;typeaheadParser&#x27;,
    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    var eventDebounceTime = 200;

    return {
      require: [&#x27;ngModel&#x27;, &#x27;^?ngModelOptions&#x27;],
      link: function(originalScope, element, attrs, ctrls) {
        var modelCtrl = ctrls[0];
        var ngModelOptions = ctrls[1];
        //SUPPORTED ATTRIBUTES (OPTIONS)

        //minimal no of characters that needs to be entered before typeahead kicks-in
        var minLength = originalScope.$eval(attrs.typeaheadMinLength);
        if (!minLength &amp;&amp; minLength !== 0) {
          minLength = 1;
        }

        //minimal wait time after last character typed before typeahead kicks-in
        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

        //should it restrict model values to the ones selected from the popup only?
        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

        //binding to a variable that indicates if matches are being retrieved asynchronously
        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

        //a callback executed when a match is selected
        var onSelectCallback = $parse(attrs.typeaheadOnSelect);

        //should it select highlighted popup value when losing focus?
        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

        //binding to a variable that indicates if there were no results after the query is completed
        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

        //If input matches an item of the list exactly, select it automatically
        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

        //INTERNAL VARIABLES

        //model setter executed upon match selection
        var parsedModel = $parse(attrs.ngModel);
        var invokeModelSetter = $parse(attrs.ngModel + &#x27;($$$p)&#x27;);
        var $setModelValue = function(scope, newValue) {
          if (angular.isFunction(parsedModel(originalScope)) &amp;&amp;
            ngModelOptions &amp;&amp; ngModelOptions.$options &amp;&amp; ngModelOptions.$options.getterSetter) {
            return invokeModelSetter(scope, {$$$p: newValue});
          } else {
            return parsedModel.assign(scope, newValue);
          }
        };

        //expressions used by typeahead
        var parserResult = typeaheadParser.parse(attrs.typeahead);

        var hasFocus;

        //Used to avoid bug in iOS webview where iOS keyboard does not fire
        //mousedown &amp; mouseup events
        //Issue #3699
        var selected;

        //create a child scope for the typeahead directive so we are not polluting original scope
        //with typeahead-specific data (matches, query etc.)
        var scope = originalScope.$new();
        var offDestroy = originalScope.$on(&#x27;$destroy&#x27;, function() {
			    scope.$destroy();
        });
        scope.$on(&#x27;$destroy&#x27;, offDestroy);

        // WAI-ARIA
        var popupId = &#x27;typeahead-&#x27; + scope.$id + &#x27;-&#x27; + Math.floor(Math.random() * 10000);
        element.attr({
          &#x27;aria-autocomplete&#x27;: &#x27;list&#x27;,
          &#x27;aria-expanded&#x27;: false,
          &#x27;aria-owns&#x27;: popupId
        });

        //pop-up element used to display matches
        var popUpEl = angular.element(&#x27;&lt;div typeahead-popup&gt;&lt;/div&gt;&#x27;);
        popUpEl.attr({
          id: popupId,
          matches: &#x27;matches&#x27;,
          active: &#x27;activeIdx&#x27;,
          select: &#x27;select(activeIdx)&#x27;,
          &#x27;move-in-progress&#x27;: &#x27;moveInProgress&#x27;,
          query: &#x27;query&#x27;,
          position: &#x27;position&#x27;
        });
        //custom item template
        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
          popUpEl.attr(&#x27;template-url&#x27;, attrs.typeaheadTemplateUrl);
        }

        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
          popUpEl.attr(&#x27;popup-template-url&#x27;, attrs.typeaheadPopupTemplateUrl);
        }

        var resetMatches = function() {
          scope.matches = [];
          scope.activeIdx = -1;
          element.attr(&#x27;aria-expanded&#x27;, false);
        };

        var getMatchId = function(index) {
          return popupId + &#x27;-option-&#x27; + index;
        };

        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
        // This attribute is added or removed automatically when the &#x60;activeIdx&#x60; changes.
        scope.$watch(&#x27;activeIdx&#x27;, function(index) {
          if (index &lt; 0) {
            element.removeAttr(&#x27;aria-activedescendant&#x27;);
          } else {
            element.attr(&#x27;aria-activedescendant&#x27;, getMatchId(index));
          }
        });

        var inputIsExactMatch = function(inputValue, index) {
          if (scope.matches.length &gt; index &amp;&amp; inputValue) {
            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
          }

          return false;
        };

        var getMatchesAsync = function(inputValue) {
          var locals = {$viewValue: inputValue};
          isLoadingSetter(originalScope, true);
          isNoResultsSetter(originalScope, false);
          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
            //it might happen that several async queries were in progress if a user were typing fast
            //but we are interested only in responses that correspond to the current view value
            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
            if (onCurrentRequest &amp;&amp; hasFocus) {
              if (matches &amp;&amp; matches.length &gt; 0) {

                scope.activeIdx = focusFirst ? 0 : -1;
                isNoResultsSetter(originalScope, false);
                scope.matches.length = 0;

                //transform labels
                for (var i = 0; i &lt; matches.length; i++) {
                  locals[parserResult.itemName] = matches[i];
                  scope.matches.push({
                    id: getMatchId(i),
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i]
                  });
                }

                scope.query = inputValue;
                //position pop-up with matches - we need to re-calculate its position each time we are opening a window
                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
                //due to other elements being rendered
                recalculatePosition();

                element.attr(&#x27;aria-expanded&#x27;, true);

                //Select the single remaining option if user input matches
                if (selectOnExact &amp;&amp; scope.matches.length === 1 &amp;&amp; inputIsExactMatch(inputValue, 0)) {
                  scope.select(0);
                }
              } else {
                resetMatches();
                isNoResultsSetter(originalScope, true);
              }
            }
            if (onCurrentRequest) {
              isLoadingSetter(originalScope, false);
            }
          }, function() {
            resetMatches();
            isLoadingSetter(originalScope, false);
            isNoResultsSetter(originalScope, true);
          });
        };

        // bind events only if appendToBody params exist - performance feature
        if (appendToBody) {
          angular.element($window).bind(&#x27;resize&#x27;, fireRecalculating);
          $document.find(&#x27;body&#x27;).bind(&#x27;scroll&#x27;, fireRecalculating);
        }

        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
        var timeoutEventPromise;

        // Default progress type
        scope.moveInProgress = false;

        function fireRecalculating() {
          if (!scope.moveInProgress) {
            scope.moveInProgress = true;
            scope.$digest();
          }

          // Cancel previous timeout
          if (timeoutEventPromise) {
            $timeout.cancel(timeoutEventPromise);
          }

          // Debounced executing recalculate after events fired
          timeoutEventPromise = $timeout(function() {
            // if popup is visible
            if (scope.matches.length) {
              recalculatePosition();
            }

            scope.moveInProgress = false;
            scope.$digest();
          }, eventDebounceTime);
        }

        // recalculate actual position and set new values to scope
        // after digest loop is popup in right position
        function recalculatePosition() {
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top += element.prop(&#x27;offsetHeight&#x27;);
        }

        resetMatches();

        //we need to propagate user&#x27;s query so we can higlight matches
        scope.query = undefined;

        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
        var timeoutPromise;

        var scheduleSearchWithTimeout = function(inputValue) {
          timeoutPromise = $timeout(function() {
            getMatchesAsync(inputValue);
          }, waitTime);
        };

        var cancelPreviousTimeout = function() {
          if (timeoutPromise) {
            $timeout.cancel(timeoutPromise);
          }
        };

        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
        modelCtrl.$parsers.unshift(function(inputValue) {
          hasFocus = true;

          if (minLength === 0 || inputValue &amp;&amp; inputValue.length &gt;= minLength) {
            if (waitTime &gt; 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }

          if (isEditable) {
            return inputValue;
          } else {
            if (!inputValue) {
              // Reset in case user had typed something previously.
              modelCtrl.$setValidity(&#x27;editable&#x27;, true);
              return null;
            } else {
              modelCtrl.$setValidity(&#x27;editable&#x27;, false);
              return undefined;
            }
          }
        });

        modelCtrl.$formatters.push(function(modelValue) {
          var candidateViewValue, emptyViewValue;
          var locals = {};

          // The validity may be set to false via $parsers (see above) if
          // the model is restricted to selected values. If the model
          // is set manually it is considered to be valid.
          if (!isEditable) {
            modelCtrl.$setValidity(&#x27;editable&#x27;, true);
          }

          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          } else {
            //it might happen that we don&#x27;t have enough info to properly render input value
            //we need to check for this situation and simply return model value if we can&#x27;t apply custom formatting
            locals[parserResult.itemName] = modelValue;
            candidateViewValue = parserResult.viewMapper(originalScope, locals);
            locals[parserResult.itemName] = undefined;
            emptyViewValue = parserResult.viewMapper(originalScope, locals);

            return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
          }
        });

        scope.select = function(activeIdx) {
          //called from within the $digest() cycle
          var locals = {};
          var model, item;

          selected = true;
          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
          model = parserResult.modelMapper(originalScope, locals);
          $setModelValue(originalScope, model);
          modelCtrl.$setValidity(&#x27;editable&#x27;, true);
          modelCtrl.$setValidity(&#x27;parse&#x27;, true);

          onSelectCallback(originalScope, {
            $item: item,
            $model: model,
            $label: parserResult.viewMapper(originalScope, locals)
          });

          resetMatches();

          //return focus to the input element if a match was selected via a mouse click event
          // use timeout to avoid $rootScope:inprog error
          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
            $timeout(function() { element[0].focus(); }, 0, false);
          }
        };

        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
        element.bind(&#x27;keydown&#x27;, function(evt) {
          //typeahead is open and an &quot;interesting&quot; key was pressed
          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
            return;
          }

          // if there&#x27;s nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
          if (scope.activeIdx === -1 &amp;&amp; (evt.which === 9 || evt.which === 13)) {
            resetMatches();
            scope.$digest();
            return;
          }

          evt.preventDefault();

          if (evt.which === 40) {
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();

          } else if (evt.which === 38) {
            scope.activeIdx = (scope.activeIdx &gt; 0 ? scope.activeIdx : scope.matches.length) - 1;
            scope.$digest();

          } else if (evt.which === 13 || evt.which === 9) {
            scope.$apply(function () {
              scope.select(scope.activeIdx);
            });

          } else if (evt.which === 27) {
            evt.stopPropagation();

            resetMatches();
            scope.$digest();
          }
        });

        element.bind(&#x27;blur&#x27;, function() {
          if (isSelectOnBlur &amp;&amp; scope.matches.length &amp;&amp; scope.activeIdx !== -1 &amp;&amp; !selected) {
            selected = true;
            scope.$apply(function() {
              scope.select(scope.activeIdx);
            });
          }
          hasFocus = false;
          selected = false;
        });

        // Keep reference to click handler to unbind it.
        var dismissClickHandler = function(evt) {
          // Issue #3973
          // Firefox treats right click as a click on document
          if (element[0] !== evt.target &amp;&amp; evt.which !== 3 &amp;&amp; scope.matches.length !== 0) {
            resetMatches();
            if (!$rootScope.$$phase) {
              scope.$digest();
            }
          }
        };

        $document.bind(&#x27;click&#x27;, dismissClickHandler);

        originalScope.$on(&#x27;$destroy&#x27;, function() {
          $document.unbind(&#x27;click&#x27;, dismissClickHandler);
          if (appendToBody) {
            $popup.remove();
          }
          // Prevent jQuery cache memory leak
          popUpEl.remove();
        });

        var $popup = $compile(popUpEl)(scope);

        if (appendToBody) {
          $document.find(&#x27;body&#x27;).append($popup);
        } else {
          element.after($popup);
        }
      }
    };

  }])

  .directive(&#x27;typeaheadPopup&#x27;, function() {
    return {
      restrict: &#x27;EA&#x27;,
      scope: {
        matches: &#x27;=&#x27;,
        query: &#x27;=&#x27;,
        active: &#x27;=&#x27;,
        position: &#x27;&amp;&#x27;,
        moveInProgress: &#x27;=&#x27;,
        select: &#x27;&amp;&#x27;
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || &#x27;template/typeahead/typeahead-popup.html&#x27;;
      },
      link: function(scope, element, attrs) {
        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function() {
          return scope.matches.length &gt; 0;
        };

        scope.isActive = function(matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function(activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  })

  .directive(&#x27;typeaheadMatch&#x27;, [&#x27;$templateRequest&#x27;, &#x27;$compile&#x27;, &#x27;$parse&#x27;, function($templateRequest, $compile, $parse) {
    return {
      restrict: &#x27;EA&#x27;,
      scope: {
        index: &#x27;=&#x27;,
        match: &#x27;=&#x27;,
        query: &#x27;=&#x27;
      },
      link:function(scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || &#x27;template/typeahead/typeahead-match.html&#x27;;
        $templateRequest(tplUrl).then(function(tplContent) {
          $compile(tplContent.trim())(scope, function(clonedElement) {
            element.replaceWith(clonedElement);
          });
        });
      }
    };
  }])

  .filter(&#x27;typeaheadHighlight&#x27;, [&#x27;$sce&#x27;, &#x27;$injector&#x27;, &#x27;$log&#x27;, function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has(&#x27;$sanitize&#x27;);

    function escapeRegexp(queryToEscape) {
      // Regex: capture the whole query string and replace it with the string that will be used to match
      // the results, for example if the capture is &quot;a&quot; the result will be \a
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, &#x27;\\$1&#x27;);
    }

    function containsHtml(matchItem) {
      return /&lt;.*&gt;/g.test(matchItem);
    }

    return function(matchItem, query) {
      if (!isSanitizePresent &amp;&amp; containsHtml(matchItem)) {
        $log.warn(&#x27;Unsafe use of typeahead please use ngSanitize&#x27;); // Warn the user about the danger
      }
      matchItem = query? (&#x27;&#x27; + matchItem).replace(new RegExp(escapeRegexp(query), &#x27;gi&#x27;), &#x27;&lt;strong&gt;$&amp;&lt;/strong&gt;&#x27;) : matchItem; // Replaces the capture string with a the same string inside of a &quot;strong&quot; tag
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
      }
      return matchItem;
    };
  }]);
!angular.$$csp() &amp;&amp; angular.element(document).find(&#x27;head&#x27;).prepend(&#x27;&lt;style type=&quot;text/css&quot;&gt;.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}&lt;/style&gt;&#x27;);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
